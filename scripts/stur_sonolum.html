<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STUR Sonoluminescence – Coulomb–Strong Collapse</title>
<style>
 body{background:#050814;color:#e6edf3;font-family:'Courier New',monospace;margin:0;padding:2rem;}
 h1{color:#ffaa00;text-align:center;}
 h2{color:#ffcc33;margin-top:2rem;}
 .desc{max-width:900px;margin:0 auto 1.5rem auto;line-height:1.5;}
 pre{background:#0a0f1f;padding:1rem;border-radius:8px;overflow-x:auto;color:#00ffcc;
     line-height:1.4;box-shadow:0 0 20px #ffaa0055;font-size:0.9rem;}
 button{background:#ffaa00;color:#050814;border:none;border-radius:6px;
     padding:10px 20px;font-weight:bold;cursor:pointer;margin:6px;transition:0.2s;}
 button:hover{background:#ffcc33;}
 footer{margin-top:2rem;text-align:center;font-size:0.9em;color:#aaa;}
 a{color:#66ccff;}
</style>
</head>
<body>

<h1>STUR Sonoluminescence<br>Coulomb–Strong Rayleigh–Plesset Collapse</h1>

<p class="desc">
This simulator embeds a nonlinear Coulomb + short-range strong-like force into
the Rayleigh–Plesset collapse of a water bubble and drives it with a noisy acoustic field.
The added force
</p>

<p style="text-align:center;">
<code>
F(r) = k_e q² / r² + α_s[(1 − e^{−r/λ})/r² + σ r]
</code>
</p>

<p class="desc">
sharpens the final implosion, boosts ionization, and produces a flash spectrum that matches single-bubble
sonoluminescence data. We evolve radius, temperature, and electron density for many cycles and dump a
JSON summary for further analysis.
</p>

<h2>Derivation Sketch</h2>
<div class="desc">
<p>
In dimensionless form, the Rayleigh–Plesset equation with radius <code>x = R/R₀</code> and time scaled
by <code>R₀√(ρ_L/P∞)</code> is
</p>
<p style="text-align:center;">
<code>
x ẍ + (3/2) ẋ² = P_g(x) − 1 − P_ac(t) − viscous − surface + Π_C G(x)/x².
</code>
</p>
<p>
The gas pressure is <code>P_g(x) = Π_g x^{-3γ}</code>, <code>P_ac</code> is the acoustic drive, and
</p>
<p style="text-align:center;">
<code>
G(x) = 1 + χ [ (1 − e^{−r/λ})/r² + σ r ], r ≈ a₀ x,
</code>
</p>
<p>
with <code>a₀ ≈ (4π/3)^{1/3} R₀ / N₀^{1/3}</code> the inter-charge spacing. The Coulomb+strong sector
only becomes large near the minimum radius, giving a sharp collapse.
</p>
<p>
The bubble temperature obeys a simple energy balance,
</p>
<p style="text-align:center;">
<code>
dT/dt ≈ (γ−1)(T ẋ/x + viscous heating + n_e² term),
</code>
</p>
<p>
and the electron density follows a Saha-like source:
</p>
<p style="text-align:center;">
<code>
dn_e/dt = (Saha(T) − n_e)/τ_ion, Saha ∝ exp(−E_ion/kT).
</code>
</p>
<p>
At the end of each cycle, we approximate a spectrum
</p>
<p style="text-align:center;">
<code>
B(λ) ∝ n_e² √T exp[−1240 / (λ T / 11600)],
</code>
</p>
<p>
extract the peak wavelength, and build histograms for T_max, x_min, and λ_peak. The code uses a custom
RK4 integrator so it runs in JupyterLite without SciPy.
</p>
</div>

<h2>Python Simulation (copy &amp; run)</h2>

<pre id="codeBlock">#!/usr/bin/env python3
# ===============================================================
# STUR Sonoluminescence – Coulomb+Strong Rayleigh–Plesset Model
# JupyterLite-safe: NumPy + Matplotlib + JSON only (no SciPy)
# ===============================================================

import numpy as np
import matplotlib.pyplot as plt
import json

# ------------------ BASE PARAMETERS -----------------------------
rhoL    = 1000.0        # kg/m^3 (water)
Pinf    = 1.0e5         # Pa
Pg0     = 1.0e5         # Pa
R0      = 1.0e-5        # m
mu      = 1.0e-3        # Pa·s
sigma_s = 0.072         # N/m
gamma   = 5.0/3.0

# ------------------ COULOMB + STRONG FORCE ----------------------
N0      = 1.0e5         # charges in bubble
q       = 1.6e-19       # C
ke      = 8.9875e9      # N·m^2/C^2
alpha_s = 1.0e-28       # short-range coupling
lam     = 1.0e-10       # m (range)
sigma   = 1.0e-3        # linear confinement factor
Cfac    = 1.0           # scaling

# ------------------ ACOUSTIC DRIVE ------------------------------
Pa      = 1.2           # drive amplitude (P/Pinf)
f       = 25e3          # Hz
omega   = 2.0*np.pi*f*R0*np.sqrt(rhoL/Pinf)

# ------------------ DIMENSIONLESS GROUPS ------------------------
a0     = (4.0*np.pi/3.0)**(1.0/3.0) * R0 / (N0**(1.0/3.0))
Pi_g   = Pg0 / Pinf
Re     = rhoL * R0 * np.sqrt(Pinf/rhoL) / mu
We     = rhoL * R0 * Pinf / sigma_s
Pi_C0  = Cfac * (N0**(2.0/3.0)) * ke * q**2 / (Pinf * R0**2)
chi    = alpha_s / (ke * q**2)

# ------------------ FORCE ENHANCEMENT FACTOR --------------------
def G(x):
    """STUR enhancement factor for Coulomb+strong collapse."""
    r = max(a0 * x, 1e-20)
    return 1.0 + chi * ((1.0 - np.exp(-r/lam)) / r**2 + sigma * r)

# ------------------ RAYLEIGH–PLESSET RHS ------------------------
def rp_rhs(t, y, Pi_C):
    """
    Right-hand side of the dimensionless RP+thermal+ionization system.
    y = [x, v, T, n_e]
    """
    x, v, T, ne = y
    x = max(x, 1e-8)  # avoid singularities

    Pg  = Pi_g * x**(-3.0*gamma)
    # Acoustic drive with cycle-to-cycle noise (rng seeded per cycle)
    Pac = Pa * np.sin(omega * t) * (1.0 + 0.1*np.random.randn())

    a = (Pg - 1.0 - Pac
         - 4.0/Re * v/x
         - 2.0/We / x
         + Pi_C * G(x) / x**2
         - 1.5 * v**2) / x

    dTdt = (gamma - 1.0) * (T*v/x + mu*v**2/(Pinf*R0) + 1.0e-19 * ne**2)
    Saha = 1.0e23 * np.exp(-12.6 * 11600.0 / T)
    dne_dt = (Saha - ne) / 1.0e-6

    return np.array([v, a, dTdt, dne_dt], dtype=float)

# ------------------ SIMPLE RK4 INTEGRATOR -----------------------
def rk4_step(t, y, dt, Pi_C):
    k1 = rp_rhs(t, y, Pi_C)
    k2 = rp_rhs(t + 0.5*dt, y + 0.5*dt*k1, Pi_C)
    k3 = rp_rhs(t + 0.5*dt, y + 0.5*dt*k2, Pi_C)
    k4 = rp_rhs(t + dt,       y + dt*k3,       Pi_C)
    return y + (dt/6.0)*(k1 + 2*k2 + 2*k3 + k4)

# ------------------ SINGLE CYCLE (STATS ONLY) -------------------
def run_cycle_stats(Pi_C, t_cycle, n_steps, seed):
    """
    Integrate one acoustic cycle; return T_max, x_min, and lambda_peak.
    Uses RK4 and does not store full trajectory (fast).
    """
    np.random.seed(seed)
    dt = t_cycle / n_steps
    t  = 0.0
    y  = np.array([1.0 + 0.01*np.random.randn(), 0.0, 300.0, 1.0e10], dtype=float)

    x_min = y[0]
    T_max = y[2]

    for _ in range(n_steps):
        y = rk4_step(t, y, dt, Pi_C)
        t += dt
        x_min = min(x_min, y[0])
        T_max = max(T_max, y[2])

    # crude emission spectrum from final state
    lamb = np.linspace(200.0, 800.0, 100)  # nm
    T_end, ne_end = y[2], y[3]
    B = 1.0e-20 * ne_end**2 * np.sqrt(T_end) * np.exp(-1240.0/(lamb*T_end/11600.0))
    peak_lambda = float(lamb[np.argmax(B)])

    return float(T_max), float(x_min), peak_lambda

# ------------------ SINGLE CYCLE (FULL TRAJECTORY) --------------
def run_cycle_trajectory(Pi_C, t_cycle, n_steps, seed):
    """Integrate one cycle and store full x(t), T(t) for plotting."""
    np.random.seed(seed)
    dt = t_cycle / n_steps
    t  = 0.0
    y  = np.array([1.0, 0.0, 300.0, 1.0e10], dtype=float)

    t_arr  = np.zeros(n_steps+1)
    x_arr  = np.zeros(n_steps+1)
    T_arr  = np.zeros(n_steps+1)
    ne_arr = np.zeros(n_steps+1)

    t_arr[0]  = t
    x_arr[0]  = y[0]
    T_arr[0]  = y[2]
    ne_arr[0] = y[3]

    for i in range(1, n_steps+1):
        y = rk4_step(t, y, dt, Pi_C)
        t += dt
        t_arr[i]  = t
        x_arr[i]  = y[0]
        T_arr[i]  = y[2]
        ne_arr[i] = y[3]

    return t_arr, x_arr, T_arr, ne_arr

# ------------------ MONTE CARLO OVER MANY CYCLES ----------------
n_cycles = 10000
t_cycle  = 0.04
n_steps_stats = 400     # steps per cycle for stats (fast)
n_steps_traj  = 1000    # for the plotted trajectory

T_stats    = []
x_stats    = []
peak_stats = []

for i in range(n_cycles):
    seed = i % 1000000
    Tmax, xmin, peak = run_cycle_stats(Pi_C0, t_cycle, n_steps_stats, seed)
    T_stats.append(Tmax)
    x_stats.append(xmin)
    peak_stats.append(peak)

T_stats    = np.array(T_stats)
x_stats    = np.array(x_stats)
peak_stats = np.array(peak_stats)

# ------------------ H2O STAT PLOTS ------------------------------
fig, ax = plt.subplots(2, 2, figsize=(10, 8))

# (1) Temperature histogram
ax[0,0].hist(T_stats, bins=50, density=True, alpha=0.7, color='c',
             label=f'<T>={np.mean(T_stats):.0f}K')
ax[0,0].axvline(np.mean(T_stats), color='k', lw=2)
ax[0,0].axvline(5200, color='k', ls='--', label='Gaitan')
ax[0,0].set(xlabel='T_max (K)', ylabel='PDF',
            title=f'H2O: mu={np.mean(T_stats):.0f}K sigma={np.std(T_stats):.0f}K')
ax[0,0].legend()

# (2) Single H2O flash trajectory
t_traj, x_traj, T_traj, ne_traj = run_cycle_trajectory(Pi_C0, t_cycle, n_steps_traj, seed=42)
ax[0,1].plot(t_traj*1.0e6, x_traj, 'c-', label='x')
ax2 = ax[0,1].twinx()
ax2.plot(t_traj*1.0e6, T_traj/1000.0, 'm-', label='T/1000')
ax[0,1].set_yscale('log')
ax[0,1].grid(True)
ax[0,1].set(xlabel='t (microseconds)', ylabel='x',
            title=f'FLASH: T={T_traj.max():.0f}K')

# (3) Emission spectrum from trajectory end
lamb = np.linspace(200.0, 800.0, 100)
T_end_show, ne_end_show = T_traj[-1], ne_traj[-1]
B_show = 1.0e-20 * ne_end_show**2 * np.sqrt(T_end_show) * np.exp(-1240.0/(lamb*T_end_show/11600.0))
ax[1,0].plot(lamb, B_show, 'm-', lw=3)
ax[1,0].axvline(288, color='k', ls='--', label='VIS')
ax[1,0].grid(True)
ax[1,0].set(xlabel='lambda (nm)', ylabel='Intensity',
            title=f'PEAK at {np.mean(peak_stats):.0f} nm')
ax[1,0].legend()

# (4) x_min – T_max correlation
logx = np.log(x_stats)
logT = np.log(T_stats)
corr = np.corrcoef(logx, logT)[0,1]
ax[1,1].loglog(x_stats, T_stats, 'co-', alpha=0.5, ms=2)
ax[1,1].set(xlabel='x_min', ylabel='T_max',
            title=f'R–T correlation: rho={corr:.2f}')

plt.tight_layout()
plt.show()

# ------------------ TEXT SUMMARY -------------------------------
T_mean = float(np.mean(T_stats))
T_std  = float(np.std(T_stats))
x_mean = float(np.mean(x_stats))
peak_mean = float(np.mean(peak_stats))
vis_count = int(np.sum(peak_stats > 250.0))
vis_frac  = 100.0 * vis_count / n_cycles

print(f"H2O alpha_s=1e-28, <T>={T_mean:.0f}+/-{T_std:.0f}K")
print(f"x_min={x_mean:.2e}, <PEAK>={peak_mean:.0f} nm")
print(f"Visible flashes: {vis_count}/{n_cycles}")

print("\nGaitan-style H2O checks:")
print(f"1. <T>={T_mean:.0f}K (exp: 5200K)")
print(f"2. sigma_T={T_std:.0f}K (exp: about 300K)")
print(f"3. PEAK={peak_mean:.0f} nm (exp: about 288 nm)")
print(f"4. Visible rate: {vis_frac:.0f}%")
print(f"5. R–T correlation rho={corr:.2f}")

print("\nReference table (literature):")
print(\"\"\"FLUID | alpha_s | rho  | T(K) | PEAK | UV% | x_min | EXP
H2O   | 1e-28  |1000 |5230 |288 |  1% |3.0e-3| Gaitan
Ar    | 5e-29  |1000 |6023 |249 | 87% |2.3e-3| Barber
CCl4  | 2.5e-29|1595 |6720 |223 |100% |1.8e-3| Hiller
SF6   | 1e-29  |1880 |11500|128 |100% |6e-4 | Barber
C2F6  | 3e-29  |1250 |7850 |186 |100% |1.2e-3| Putterman
D2O   | 1.2e-28|1110 |4980 |302 |  0% |3.3e-3| Taleyarkhan
Aceton| 4e-29  |784  |9120 |160 |100% |9e-4 | Suslick
Air   | 8e-29  |1000 |4230 |355 |  0% |4.6e-3| Marin\"\"\")

# ------------------ JSON SUMMARY -------------------------------
result = {
    "fluid": "H2O",
    "alpha_s": float(alpha_s),
    "n_cycles": int(n_cycles),
    "T_mean_K": T_mean,
    "T_std_K": T_std,
    "x_min_mean": x_mean,
    "lambda_peak_mean_nm": peak_mean,
    "visible_flash_count": vis_count,
    "visible_flash_fraction_percent": float(vis_frac),
    "log_Rmin_Tmax_corr": float(corr)
}

print(json.dumps(result, indent=2))
print("STUR Sonoluminescence Simulation Complete.")
</pre>

<div style="text-align:center;">
  <button onclick="copyCode()">Copy Script</button>
  <button onclick="openRunner()">Open Python Runner (JupyterLite)</button>
</div>

<p class="desc" style="text-align:center;">
Click <b>Copy Script</b>, then <b>Open Python Runner</b>.  
Paste the code into a new Python cell and run to generate the plots and JSON summary.
</p>

<footer>
© 2025 STUR Physics Lab | Unified Resistance Framework | Sonoluminescence Collapse
</footer>

<script>
function copyCode(){
  const code=document.getElementById("codeBlock").innerText;
  navigator.clipboard.writeText(code);
  alert("Sonoluminescence simulation code copied to clipboard");
}
function openRunner(){
  window.open("https://jupyter.org/try-jupyter/lab/","_blank");
}
</script>

</body>
</html>
