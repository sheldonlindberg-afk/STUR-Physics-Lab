<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STUR-ATP Mito Sim 5.5 – 1000 Mito Population</title>
<style>
body{background:#050814;color:#e6edf3;font-family:'Courier New',monospace;margin:0;padding:2rem;}
h1{color:#ffaa00;text-align:center;}
h2{color:#ffcc33;margin-top:2rem;}
.desc{max-width:900px;margin:0 auto 1.5rem auto;line-height:1.5;}
pre{background:#0a0f1f;padding:1rem;border-radius:8px;overflow-x:auto;color:#00ffcc;
    line-height:1.4;box-shadow:0 0 20px #ffaa0055;}
button{background:#ffaa00;color:#050814;border:none;border-radius:6px;
    padding:10px 20px;font-weight:bold;cursor:pointer;margin:6px;transition:0.2s;}
button:hover{background:#ffcc33;}
footer{margin-top:2rem;text-align:center;font-size:0.9em;color:#aaa;}
</style>
</head>
<body>

<h1>STUR-ATP Mito Sim 5.5 – 1000 Mito Population</h1>

<p class="desc">
Full mitochondrial population simulation under the <b>STUR Unified Resistance Framework</b>.  
Each mitochondrion behaves as a resistance oscillator coupled through <code>S_STUR(r)</code>,  
governing curvature-dependent potential U(r), feedback tunneling, ROS generation,  
Ca²⁺ loading, mPTP opening, and thermal balance.  
Three physiological modes – healthy, uncoupled, apoptotic – are simulated in parallel.
</p>

<h2>Derivation Overview (Condensed)</h2>
<div class="desc">
<ol>
<li><code>S_STUR(r,L₀)=tanh(r/L₀)(1−e^{−r/L₀})</code> couples curvature to resistance.</li>
<li>Coupled ODEs evolve pmf(t), ATP(t), ROS, T(t), Damage, Ca²⁺, mPTP state.</li>
<li>Population statistics over 100 s demonstrate bioenergetic stability and failure pathways.</li>
</ol>
</div>

<h2>Python Simulation (copy &amp; run)</h2>

<pre id="codeBlock">
#!/usr/bin/env python3
# ===============================================================
# STUR-ATP Mito Sim 5.5 – Ultimate 1000-Mito Population (JupyterLite-Safe)
# ===============================================================
import sys, subprocess, os, math, json, numpy as np, matplotlib.pyplot as plt
from scipy.ndimage import gaussian_filter

for pkg in ["numpy","matplotlib","scipy"]:
    try: __import__(pkg)
    except Exception: subprocess.run([sys.executable,"-m","pip","install",pkg])

NA=6.022e23; E_ATP=5e4/NA; V_mito_L=1e-15; ATP_cyto_M=5e-3

def S_STUR(r,L0): x=r/L0; return math.tanh(x)*(1-math.exp(-x))

def ATP_use_rate_func(t):
    base=5e4; burst=0
    if 20<t<40: burst=2e5*math.exp(-((t-30)**2)/(2*25))
    return base+burst

def run_sim(MODE="healthy",Tmax=100,dt=0.001,seed=1,N_mito=1000):
    np.random.seed(seed)
    steps=int(Tmax/dt)+1; t=np.linspace(0,Tmax,steps,dtype=float)
    L0,Rd,Rl,Rf=0.25,0.3,0.6,1.0
    Sd,Sl,St=S_STUR(Rd,L0),S_STUR(Rl,L0),S_STUR(Rf,L0)
    C_eff,drive_scale,tau_NADH,NADH_period=5,400,4,2
    E0_mV,R0,R_load=220,1e7,5e7; eta_batt,eta_elec=0.8,0.6
    V0_barrier,alpha,noise_sigma=1,3.5,0.4
    pmf_soft,pmf_span,leak_fb_g,pmf_clip=240,150,0.5,500
    if MODE=="healthy": k_drive0,k_leak_base,gamma_ATP,ros_gain,ros_thresh=4,3e-4,3e-5,5e-4,220
    elif MODE=="uncoupled": k_drive0,k_leak_base,gamma_ATP,ros_gain,ros_thresh=4,1.5e-3,2e-5,5e-4,190
    else: k_drive0,k_leak_base,gamma_ATP,ros_gain,ros_thresh=4.8,2.5e-3,4e-5,6e-3,160
    ros_thresh*=0.6
    k_damage,k_leak_damage,D_thresh,pmf_mptp=1e-5,5.0,0.5,140.0
    Ca0_uM,k_Ca_in_base,k_Ca_in_ROS,k_Ca_clear,Ca_thresh_uM=0.1,0.005,0.05,0.05,0.5

    def jitter(val,sig): return (val*np.random.lognormal(0,sig,N_mito)).astype(float)
    k_drive0_vec=jitter(k_drive0,0.1); k_leak_base_vec=jitter(k_leak_base,0.1)
    gamma_ATP_vec=jitter(gamma_ATP,0.05); ros_gain_vec=jitter(ros_gain,0.05)
    E0_vec=jitter(E0_mV,0.05); R0_vec=jitter(R0,0.05)
    D_thresh_vec=jitter(D_thresh,0.05); Ca_thresh_vec=jitter(Ca_thresh_uM,0.05)

    pmf=np.full(N_mito,20.0,float); ATP=np.full(N_mito,ATP_cyto_M*NA*V_mito_L,float)
    T=np.full(N_mito,37.0,float); Damage=np.zeros(N_mito,float); Ca=np.full(N_mito,Ca0_uM,float)
    E_ROS_vec=np.zeros(N_mito,float); mptp_open=np.zeros(N_mito,bool)

    keys=["pmf","ATP","E_ROS","T","Damage","Ca","mptp"]
    pop={k+"_mean":np.zeros(steps,float) for k in keys}
    pop.update({k+"_std":np.zeros(steps,float) for k in ["pmf","ATP","T","Damage","Ca"]})

    def record(i):
        pop["pmf_mean"][i]=pmf.mean(); pop["ATP_mean"][i]=ATP.mean()
        pop["E_ROS_mean"][i]=E_ROS_vec.mean(); pop["T_mean"][i]=T.mean()
        pop["Damage_mean"][i]=Damage.mean(); pop["Ca_mean"][i]=Ca.mean()
        pop["mptp_mean"][i]=mptp_open.mean()

    record(0)
    for i in range(steps-1):
        ti=t[i]; pmf=np.clip(pmf,0,pmf_clip)
        NADH=(0.5+0.5*math.sin(2*math.pi*ti/NADH_period))*math.exp(-ti/tau_NADH)
        NADH=max(NADH,0); pmf_pop=pmf.mean()
        if pmf_pop>pmf_soft:
            x=(pmf_pop-pmf_soft)/pmf_span; pump_factor=max(0,1-x); leak_fb=1+leak_fb_g*x
        else:
            pump_factor=1; leak_fb=1

        leak_eff=(k_leak_base_vec*(1+k_leak_damage*Damage)).astype(float)
        if MODE=="apoptotic":
            trigger=(~mptp_open)&((Damage>D_thresh_vec)|(Ca>Ca_thresh_vec))&(pmf>pmf_mptp)
            mptp_open|=trigger

        # Force float64 before in-place math
        leak_eff=np.array(leak_eff,dtype=np.float64,copy=True)
        pump_mult=np.full(N_mito,pump_factor,dtype=np.float64)

        leak_eff[mptp_open]=leak_eff[mptp_open]*50.0
        pump_mult[mptp_open]=pump_mult[mptp_open]*0.1

        P_drive=drive_scale*k_drive0_vec*Sd*NADH*pump_mult
        leak_raw=leak_eff*Sl*pmf*leak_fb
        E_emf=(E0_vec*Sd*NADH)*1e-3; R_int=R0_vec/(1+Sl)
        I=np.maximum(E_emf/(R_load+R_int),0); P_el=E_emf*I; ATP_batt=eta_batt*P_el/E_ATP
        S_torq=np.tanh(pmf/180)*St; barrier=np.clip(V0_barrier*(1-S_torq),0,5)
        Tun=np.exp(-alpha*barrier)
        P_leak=np.abs(leak_raw*1e-12*pmf*1e-3); ATP_leak=eta_elec*P_leak/E_ATP
        over=np.maximum(pmf-ros_thresh,0); ros=ros_gain_vec*over; P_ros=ros*0.05*E_ATP
        ATP_prod=(ATP_batt+ATP_leak)*Tun; ATP_use=ATP_use_rate_func(ti)
        E_ROS_vec+=P_ros*dt
        dpmf=(P_drive-leak_eff*pmf-gamma_ATP_vec*ATP_prod-2e-3*ros)/C_eff
        dpmf+=np.random.normal(0,noise_sigma,N_mito)/dt
        pmf=np.clip(pmf+dpmf*dt,0,pmf_clip)
        ATP=np.maximum(ATP+(ATP_prod-ATP_use)*dt,0)
        Damage+=k_damage*ros*dt
        Ca+=(k_Ca_in_base+k_Ca_in_ROS*ros)*dt-k_Ca_clear*(Ca-Ca0_uM)*dt
        record(i+1)

    pop["t"]=t; pop["MODE"]=MODE; return pop

# ---------- Run and Plot ----------
modes=["healthy","uncoupled","apoptotic"]
results=[run_sim(m,100,0.001,1,1000) for m in modes]
print("Simulation complete.")

labels=["Healthy","Uncoupled","Apoptotic"]; colors=["tab:green","tab:orange","tab:red"]
def smooth(y,sigma=3):
    try: return gaussian_filter(y,sigma=sigma)
    except Exception: return y

fig,axes=plt.subplots(3,2,figsize=(12,10),sharex=True)
ax_pmf,ax_atp,ax_ros,ax_T,ax_D,ax_Ca=axes.flatten()
for res,lab,col in zip(results,labels,colors):
    t=res["t"]
    ax_pmf.plot(t,smooth(res["pmf_mean"]),label=lab,color=col)
    ax_atp.plot(t,smooth(res["ATP_mean"]),label=lab,color=col)
    ax_ros.plot(t,smooth(res["E_ROS_mean"]),label=lab,color=col)
    ax_T.plot(t,smooth(res["T_mean"]),label=lab,color=col)
    ax_D.plot(t,smooth(res["Damage_mean"]),label=lab,color=col)
    ax_Ca.plot(t,smooth(res["Ca_mean"]),label=lab,color=col)

for a in axes.flatten(): a.grid(True,alpha=0.3)
ax_pmf.set_ylabel("pmf (mV)"); ax_atp.set_ylabel("ATP (mols)")
ax_ros.set_ylabel("ROS"); ax_T.set_ylabel("T (°C)")
ax_D.set_ylabel("Damage"); ax_Ca.set_ylabel("Ca²⁺ (µM)")
ax_Ca.set_xlabel("Time (s)"); ax_pmf.legend()
plt.tight_layout(); plt.show()

plt.figure(figsize=(6,4))
for res,lab,col in zip(results,labels,colors):
    plt.plot(res["t"],res["mptp_mean"],label=lab,color=col)
plt.xlabel("Time (s)"); plt.ylabel("mPTP Open Fraction")
plt.title("mPTP Opening – Population Fraction")
plt.grid(True,alpha=0.3); plt.legend(); plt.tight_layout(); plt.show()
</pre>

<div style="text-align:center;">
  <button onclick="copyCode()">Copy Script</button>
  <button onclick="openRunner()">Open Python Runner (JupyterLite)</button>
</div>

<p class="desc" style="text-align:center;">
Click <b>Copy Script</b>, then <b>Open Python Runner</b>.  
In JupyterLite, paste the code into a new cell and run it to see the population plots and outputs.
</p>

<footer>
© 2025 STUR Physics Lab | Unified Resistance Framework | STUR-ATP Mito Sim 5.5
</footer>

<script>
function copyCode(){
  const code=document.getElementById("codeBlock").innerText;
  navigator.clipboard.writeText(code);
  alert("✅ STUR-ATP Mito Sim 5.5 code copied to clipboard");
}
function openRunner(){
  window.open("https://jupyter.org/try-jupyter/lab/","_blank");
}
</script>

</body>
</html>
