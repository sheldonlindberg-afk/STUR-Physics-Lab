<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STUR-ATP Mito Sim 5.5 – 1000 Mito Population</title>
<style>
body{background:#050814;color:#e6edf3;font-family:'Courier New',monospace;margin:0;padding:2rem;}
h1{color:#ffaa00;text-align:center;}
h2{color:#ffcc33;margin-top:2rem;}
.desc{max-width:900px;margin:0 auto 1.5rem auto;line-height:1.5;}
pre{background:#0a0f1f;padding:1rem;border-radius:8px;overflow-x:auto;color:#00ffcc;
    line-height:1.4;box-shadow:0 0 20px #ffaa0055;}
button{background:#ffaa00;color:#050814;border:none;border-radius:6px;
    padding:10px 20px;font-weight:bold;cursor:pointer;margin:6px;transition:0.2s;}
button:hover{background:#ffcc33;}
footer{margin-top:2rem;text-align:center;font-size:0.9em;color:#aaa;}
</style>
</head>
<body>

<h1>STUR-ATP Mito Sim 5.5 – 1000 Mito Population</h1>

<p class="desc">
Full mitochondrial population simulation under the <b>STUR Unified Resistance Framework</b>.  
Each mitochondrion behaves as a resistance oscillator coupled through <code>S_STUR(r)</code>,  
governing curvature-dependent potential U(r), feedback tunneling, ROS generation,  
Ca²⁺ loading, mPTP opening, and thermal balance.  
Three physiological modes – healthy, uncoupled, apoptotic – are simulated in parallel.
</p>

<h2>Derivation Overview (Condensed)</h2>
<div class="desc">
<ol>
<li><code>S_STUR(r,L₀)=tanh(r/L₀)(1−e^{−r/L₀})</code> couples curvature to resistance.</li>
<li>Coupled ODEs evolve pmf(t), ATP(t), ROS, T(t), Damage, Ca²⁺, mPTP state.</li>
<li>Population statistics over 100 s demonstrate bioenergetic stability and failure pathways.</li>
</ol>
</div>

<h2>Python Simulation (copy &amp; run)</h2>

<pre id="codeBlock">
import math, numpy as np, matplotlib.pyplot as plt

# --- Core STUR functions ---
def S_STUR(r, L0):
    x = r / L0
    return math.tanh(x) * (1 - math.exp(-x))

def ATP_use_rate_func(t):
    base = 5e4
    burst = 0.0
    if 20 < t < 40:
        burst = 2e5 * math.exp(-((t - 30)**2) / (2 * 25))
    return base + burst

# --- Simulation ---
def run_sim(MODE="healthy", Tmax=100.0, dt=0.002, N_mito=1000):
    np.random.seed(1)
    steps = int(Tmax / dt)
    t = np.linspace(0, Tmax, steps)

    # geometry + constants
    L0, Rd, Rl, Rf = 0.25, 0.3, 0.6, 1.0
    Sd, Sl, St = S_STUR(Rd, L0), S_STUR(Rl, L0), S_STUR(Rf, L0)
    C_eff, drive_scale, tau_NADH, NADH_period = 5, 400, 4, 2
    pmf_soft, pmf_span, leak_fb_g, pmf_clip = 240, 150, 0.5, 500

    if MODE == "healthy":
        k_drive0, k_leak_base, gamma_ATP, ros_gain, ros_thresh = 4, 3e-4, 3e-5, 5e-4, 220
    elif MODE == "uncoupled":
        k_drive0, k_leak_base, gamma_ATP, ros_gain, ros_thresh = 4, 1.5e-3, 2e-5, 5e-4, 190
    else:
        k_drive0, k_leak_base, gamma_ATP, ros_gain, ros_thresh = 4.8, 2.5e-3, 4e-5, 6e-3, 160
    ros_thresh *= 0.6

    k_damage, k_leak_damage, D_thresh, pmf_mptp = 1e-5, 5.0, 0.5, 140.0
    Ca0_uM, k_Ca_in_base, k_Ca_in_ROS, k_Ca_clear, Ca_thresh_uM = 0.1, 0.005, 0.05, 0.05, 0.5

    def jitter(v, s): 
        return v * np.random.lognormal(0, s, N_mito).astype(np.float64)

    k_drive0_vec = jitter(k_drive0, 0.1)
    k_leak_base_vec = jitter(k_leak_base, 0.1)
    gamma_ATP_vec = jitter(gamma_ATP, 0.05)
    ros_gain_vec = jitter(ros_gain, 0.05)
    D_thresh_vec = jitter(D_thresh, 0.05)
    Ca_thresh_vec = jitter(Ca_thresh_uM, 0.05)

    pmf = np.full(N_mito, 20.0)
    ATP = np.full(N_mito, 1e-3)
    Damage = np.zeros(N_mito)
    Ca = np.full(N_mito, Ca0_uM)
    mptp_open = np.zeros(N_mito, bool)

    means = {"pmf": [], "ATP": [], "Damage": [], "Ca": [], "mptp": []}

    for i in range(steps):
        ti = t[i]
        pmf = np.clip(pmf, 0, pmf_clip)

        NADH = (0.5 + 0.5 * math.sin(2 * math.pi * ti / NADH_period)) * math.exp(-ti / tau_NADH)
        NADH = max(NADH, 0)
        pmf_pop = pmf.mean()

        if pmf_pop > pmf_soft:
            x = (pmf_pop - pmf_soft) / pmf_span
            pump_factor = max(0, 1 - x)
            leak_fb = 1 + leak_fb_g * x
        else:
            pump_factor, leak_fb = 1, 1

        leak_eff = k_leak_base_vec * (1 + k_leak_damage * Damage)
        leak_eff = np.where(mptp_open, leak_eff * 50.0, leak_eff)
        pump_mult = np.where(mptp_open, 0.1 * pump_factor, pump_factor)

        P_drive = drive_scale * k_drive0_vec * Sd * NADH * pump_mult
        ros = ros_gain_vec * np.maximum(pmf - ros_thresh, 0)
        ATP_use = ATP_use_rate_func(ti)

        dpmf = (P_drive - leak_eff * pmf - gamma_ATP_vec * ATP_use - 2e-3 * ros) / C_eff
        dpmf += np.random.normal(0, 0.4, N_mito)
        pmf = np.clip(pmf + dpmf * dt, 0, pmf_clip)
        ATP += (pump_factor - ATP_use) * dt * 1e-6
        Damage += k_damage * ros * dt
        Ca += (k_Ca_in_base + k_Ca_in_ROS * ros) * dt - k_Ca_clear * (Ca - Ca0_uM) * dt

        mptp_open = mptp_open | ((Damage > D_thresh_vec) & (Ca > Ca_thresh_vec))
        means["pmf"].append(pmf.mean())
        means["ATP"].append(ATP.mean())
        means["Damage"].append(Damage.mean())
        means["Ca"].append(Ca.mean())
        means["mptp"].append(mptp_open.mean())

    means["t"] = t
    return means

# --- Run and plot ---
modes = ["healthy", "uncoupled", "apoptotic"]
colors = ["tab:green", "tab:orange", "tab:red"]
labels = ["Healthy", "Uncoupled", "Apoptotic"]

results = [run_sim(m) for m in modes]
print("✅ Simulation complete.")

fig, axes = plt.subplots(3, 2, figsize=(12, 10), sharex=True)
(ax1, ax2, ax3, ax4, ax5, ax6) = axes.flatten()

for res, c, lab in zip(results, colors, labels):
    t = res["t"]
    ax1.plot(t, res["pmf"], color=c, label=lab)
    ax2.plot(t, res["ATP"], color=c)
    ax3.plot(t, res["Damage"], color=c)
    ax4.plot(t, res["Ca"], color=c)
    ax5.plot(t, res["mptp"], color=c)

ax1.set_ylabel("pmf (mV)")
ax2.set_ylabel("ATP")
ax3.set_ylabel("Damage")
ax4.set_ylabel("Ca²⁺")
ax5.set_ylabel("mPTP fraction")
ax6.axis("off")
ax1.legend()
for ax in axes.flatten():
    ax.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()
</pre>

<div style="text-align:center;">
  <button onclick="copyCode()">Copy Script</button>
  <button onclick="openRunner()">Open Python Runner (JupyterLite)</button>
</div>

<p class="desc" style="text-align:center;">
Click <b>Copy Script</b>, then <b>Open Python Runner</b>.  
In JupyterLite, paste the code into a new cell and run it to see the population plots and outputs.
</p>

<footer>
© 2025 STUR Physics Lab | Unified Resistance Framework | STUR-ATP Mito Sim 5.5
</footer>

<script>
function copyCode(){
  const code=document.getElementById("codeBlock").innerText;
  navigator.clipboard.writeText(code);
  alert("✅ STUR-ATP Mito Sim 5.5 code copied to clipboard");
}
function openRunner(){
  window.open("https://jupyter.org/try-jupyter/lab/","_blank");
}
</script>

</body>
</html>
