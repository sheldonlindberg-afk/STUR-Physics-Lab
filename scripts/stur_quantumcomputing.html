<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>STUR Quantum Computing Lattice ‚Äì Deterministic Continuity Sim</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Dark STUR Lab Theme -->
  <style>
    :root {
      --bg: #050710;
      --bg-alt: #0b0f1a;
      --card: #101624;
      --accent: #5ad0ff;
      --accent-soft: rgba(90, 208, 255, 0.15);
      --text: #f5f7ff;
      --text-muted: #a7b0c8;
      --border: #20283a;
      --code-bg: #050811;
      --danger: #ff4d6a;
      --success: #3bd98f;
      --mono: "SF Mono", Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      --sans: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: var(--sans);
      background: radial-gradient(circle at top, #151c2f 0, #050710 55%);
      color: var(--text);
      -webkit-font-smoothing: antialiased;
    }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }

    header {
      padding: 1.5rem 1.5rem 0.75rem;
      border-bottom: 1px solid var(--border);
      backdrop-filter: blur(16px);
      background: linear-gradient(to bottom, rgba(5,7,16,0.96), rgba(5,7,16,0.86));
      position: sticky;
      top: 0;
      z-index: 10;
    }
    .title {
      font-size: 1.3rem;
      font-weight: 650;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: var(--accent);
      margin-bottom: 0.3rem;
    }
    .subtitle {
      font-size: 0.95rem;
      color: var(--text-muted);
      max-width: 52rem;
    }

    main {
      padding: 1.5rem;
      max-width: 1100px;
      margin: 0 auto 3rem;
    }
    section {
      margin-bottom: 1.75rem;
      background: linear-gradient(145deg, var(--bg-alt), var(--card));
      border-radius: 0.9rem;
      border: 1px solid var(--border);
      padding: 1.2rem 1.4rem;
      box-shadow: 0 18px 40px rgba(0,0,0,0.45);
    }
    section h2 {
      margin: 0 0 0.75rem;
      font-size: 1.15rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--accent);
    }
    section h3 {
      margin: 1rem 0 0.4rem;
      font-size: 1rem;
      color: var(--text);
    }
    p {
      margin: 0.3rem 0 0.5rem;
      font-size: 0.92rem;
      color: var(--text-muted);
    }
    ul {
      margin: 0.35rem 0 0.4rem 1.3rem;
      padding: 0;
      font-size: 0.9rem;
      color: var(--text-muted);
    }
    li { margin-bottom: 0.25rem; }

    .pill-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
      margin-top: 0.3rem;
    }
    .pill {
      font-size: 0.75rem;
      padding: 0.05rem 0.55rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(5, 8, 18, 0.9);
      color: var(--text-muted);
      white-space: nowrap;
    }

    pre, code {
      font-family: var(--mono);
      font-size: 0.8rem;
    }
    .json-block {
      background: var(--code-bg);
      border-radius: 0.7rem;
      padding: 0.7rem 0.85rem;
      border: 1px solid #1c2335;
      max-height: 280px;
      overflow: auto;
      margin-top: 0.4rem;
    }

    .figure-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 1rem;
      margin-top: 0.6rem;
    }
    figure {
      margin: 0;
      background: rgba(2, 5, 14, 0.9);
      border-radius: 0.7rem;
      border: 1px solid var(--border);
      overflow: hidden;
    }
    figure img {
      display: block;
      width: 100%;
      height: auto;
    }
    figcaption {
      padding: 0.35rem 0.6rem 0.55rem;
      font-size: 0.8rem;
      color: var(--text-muted);
      border-top: 1px solid rgba(255,255,255,0.03);
    }

    .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      margin-top: 0.6rem;
    }
    .btn {
      border-radius: 999px;
      padding: 0.45rem 0.95rem;
      font-size: 0.86rem;
      border: 1px solid var(--accent);
      background: radial-gradient(circle at top left, var(--accent-soft), rgba(0,0,0,0.9));
      color: var(--text);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      text-decoration: none;
    }
    .btn.secondary {
      border-color: #3f4760;
      background: radial-gradient(circle at top left, rgba(99,140,255,0.08), rgba(0,0,0,0.9));
      color: var(--text-muted);
    }
    .btn span.icon {
      font-size: 1rem;
      line-height: 1;
    }

    .script-shell {
      margin-top: 0.6rem;
      border-radius: 0.8rem;
      border: 1px solid var(--border);
      background: radial-gradient(circle at top, #070b15 0, #02030a 55%);
      padding: 0.6rem;
    }
    .script-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.4rem;
      margin-bottom: 0.4rem;
      font-size: 0.78rem;
      color: var(--text-muted);
    }
    .script-meta small strong {
      color: var(--accent);
    }
    textarea#python-script {
      width: 100%;
      min-height: 420px;
      resize: vertical;
      background: transparent;
      border: none;
      outline: none;
      color: var(--text);
      font-family: var(--mono);
      font-size: 0.8rem;
      line-height: 1.4;
      padding: 0.4rem;
      tab-size: 4;
      white-space: pre;
      overflow: auto;
    }

    .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      margin-top: 0.4rem;
      font-size: 0.78rem;
    }
    .badge {
      padding: 0.1rem 0.5rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.6);
      color: var(--text-muted);
    }

    @media (max-width: 640px) {
      header { padding: 1rem 1rem 0.75rem; }
      main   { padding: 1rem; }
      section { padding: 1rem 1.05rem; }
    }
  </style>

  <!-- MathJax for STUR derivations -->
  <script>
    window.MathJax = {
      tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
      svg: { fontCache: 'global' }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>
<body>
<header>
  <div class="title">STUR Quantum Computing Lattice</div>
  <div class="subtitle">
    Deterministic continuity simulation with no Born-rule probability:
    resistance-flux conservation, site-resolved currents, and information-based entanglement.
  </div>
</header>

<main>

  <!-- JSON summary at top -->
  <section id="json-summary-section">
    <h2>1. STUR Simulation JSON Summary</h2>
    <p>
      This block mirrors the output of <code>stur_qc_summary.json</code> created by the
      simulation. It exposes the key run parameters and ranges
      (lattice size, time step, density &amp; current bounds, and global invariants)
      for quick comparison across STUR experiments.
    </p>
    <div class="pill-row">
      <div class="pill">File: <code>stur_qc_summary.json</code></div>
      <div class="pill">Source: STUR QC Lattice flow run</div>
    </div>
    <div class="json-block">
      <pre id="json-summary">(loading stur_qc_summary.json...)</pre>
    </div>
    <p style="margin-top:0.5rem;">
      To update these numbers, re-run the Python script, upload the new
      <code>stur_qc_summary.json</code> next to this HTML file, and refresh.
    </p>
  </section>

  <!-- Full derivations before script -->
  <section id="derivation">
    <h2>2. STUR Field Derivations (No Probability)</h2>

    <h3>2.1 STUR radial resistance modulator</h3>
    <p>
      The STUR framework replaces probabilistic amplitudes with a deterministic
      resistance field shaped by a universal modulator
      \[
        \mathcal{S}(r; L_0)
          = \tanh\!\left(\frac{r}{L_0}\right)\!
            \Bigl(1 - e^{-r/L_0}\Bigr),
      \]
      where \(L_0\) is the characteristic STUR length scale and \(r\) is a
      geometric or effective curvature distance along the lattice.
    </p>

    <h3>2.2 STUR resistance generator on a qubit lattice</h3>
    <p>
      For \(N\) qubits on a 1D lattice with positions \(r_i = i a_{\mathrm{lat}}\),
      the usual Hamiltonian is replaced by a Hermitian
      <em>resistance generator</em> \(R_{\text{STUR}}\):
      \[
      R_{\text{STUR}} =
        \sum_{i} h_0\,\mathcal{S}(r_i;L_0)\,\sigma_z^{(i)}
        + \sum_{i&lt;j} J_0\,\mathcal{S}(|r_i-r_j|;L_0)
          \Bigl(\sigma_x^{(i)}\sigma_x^{(j)}+\sigma_y^{(i)}\sigma_y^{(j)}\Bigr)
        + \Omega\sum_i \mathcal{S}(r_i;L_0)\,\sigma_x^{(i)}.
      \]
      Here \(h_0\), \(J_0\), and \(\Omega\) are base scales for bias, coupling,
      and transverse drive, which are all modulated by \(\mathcal{S}\).
    </p>

    <h3>2.3 Deterministic STUR evolution without Born rule</h3>
    <p>
      The state \(\Psi(t)\) is a complex STUR resistance field in a
      \(2^N\)-dimensional configuration space, not a probability amplitude.
      Its evolution law is Schr√∂dinger-like but interpreted deterministically:
      \[
        i\hbar \,\frac{d}{dt}\,\Psi(t)
          = R_{\text{STUR}}\,\Psi(t).
      \]
      The simulation enforces a finite field norm numerically, but never uses
      \(|\Psi|^2\) as a Born probability; instead, all observables are derived
      as resistance and information measures.
    </p>

    <h3>2.4 Global resistance-flux conservation</h3>
    <p>
      For time-independent \(R_{\text{STUR}}\), the global <em>resistance flux</em>
      \[
        \Phi_R(t) = \Re\bigl[\Psi^\dagger(t)\,R_{\text{STUR}}\,\Psi(t)\bigr]
      \]
      is invariant under the evolution, analogously to conserved energy in
      closed quantum systems. In a continuum picture, this corresponds to
      \(\partial_t \rho_R + \nabla\!\cdot\!\mathbf{J}_R = 0\) with
      \(\Phi_R = \int \rho_R\,dV\) constant.
    </p>

    <h3>2.5 Local densities and bond currents</h3>
    <p>
      To expose a discrete continuity law on the lattice, each site \(i\)
      is assigned a local excitation density operator
      \[
        \hat{n}_i = \frac{1 - \sigma_z^{(i)}}{2},
        \qquad
        \rho_i(t) = \langle \Psi(t)|\hat{n}_i|\Psi(t)\rangle.
      \]
      For the STUR-weighted XX+YY couplings, we define ladder operators
      \(\sigma_i^\pm = (\sigma_x^{(i)} \pm i\sigma_y^{(i)})/2\) and
      STUR bond currents
      \[
        J_{i\to j}(t)
          = 4\,J_{ij}\,\Im\bigl\langle \sigma_i^{+}\sigma_j^{-}\bigr\rangle,
        \qquad
        J_{ij} = J_0\,\mathcal{S}(|r_i-r_j|;L_0).
      \]
    </p>

    <h3>2.6 Discrete continuity equation</h3>
    <p>
      On the lattice, the STUR continuity equation becomes
      \[
        \frac{d\rho_i}{dt} + \sum_j J_{i\to j}(t) = 0,
      \]
      which the script verifies numerically using central differences
      for \(d\rho_i/dt\). The reported residual
      \(|d\rho_i/dt + \sum_j J_{i\to j}|\) is &lt; \(\mathcal{O}(10^{-4})\)
      for the example run, while total excitation
      \(\sum_i \rho_i(t)\) is conserved to machine precision.
    </p>

    <h3>2.7 Entanglement as information, not probability</h3>
    <p>
      The bipartite entanglement entropy for a split
      \(A|B\) with \(|A| = N_A\) qubits is computed as
      \[
        S_A(t) =
          - \sum_k \lambda_k(t) \log_2 \lambda_k(t),
      \]
      where \(\{\lambda_k\}\) are eigenvalues of the reduced density matrix
      \(\rho_A(t)\). These eigenvalues are interpreted purely as information
      weights of the resistance field, not as fundamental probabilities,
      preserving the STUR program of removing the Born rule from the axioms.
    </p>
  </section>

  <!-- Plots / outputs -->
  <section id="outputs">
    <h2>3. Simulation Outputs</h2>
    <p>
      The Python script below produces three static plots and a JSON summary.
      Place the images and JSON in the same directory as this HTML file:
    </p>
    <ul>
      <li><code>stur_qc_densities.png</code> ‚Äî local densities \(\rho_i(t)\)</li>
      <li><code>stur_qc_current.png</code> ‚Äî bond current \(J_{0\to 1}(t)\)</li>
      <li><code>stur_qc_globals.png</code> ‚Äî global invariants \(S_A(t)\) and \(\Phi_R(t)\)</li>
      <li><code>stur_qc_summary.json</code> ‚Äî numeric summary for programmatic use</li>
    </ul>

    <div class="figure-row">
      <figure>
        <img src="stur_qc_densities.png" alt="STUR lattice density heatmap œÅ_i(t)" />
        <figcaption>
          Local STUR density field \(\rho_i(t)\): deterministic propagation
          of a single excitation across the lattice.
        </figcaption>
      </figure>
      <figure>
        <img src="stur_qc_current.png" alt="STUR bond current J_{0‚Üí1}(t)" />
        <figcaption>
          Bond current \(J_{0\to 1}(t)\): resistance flow between neighboring sites
          in the XX+YY STUR coupling.
        </figcaption>
      </figure>
      <figure>
        <img src="stur_qc_globals.png" alt="STUR global invariants S_A(t) and Œ¶_R(t)" />
        <figcaption>
          Global invariants: entanglement entropy \(S_A(t)\) (information)
          and resistance flux \(\Phi_R(t)\) (conserved).
        </figcaption>
      </figure>
    </div>
  </section>

  <!-- Script + buttons -->
  <section id="script">
    <h2>4. STUR QC Lattice Python Script</h2>
    <p>
      This is the complete, JupyterLite-safe Python script used to generate
      the plots and JSON summary above. It contains:
    </p>
    <ul>
      <li>Deterministic STUR evolution \(i\hbar\,d\Psi/dt = R_{\text{STUR}}\Psi\)</li>
      <li>Entanglement entropy \(S_A(t)\) as an information measure</li>
      <li>Global resistance-flux invariant \(\Phi_R(t)\)</li>
      <li>Local densities \(\rho_i(t)\), bond currents \(J_{i\to j}(t)\)</li>
      <li>Continuity residual and flow visualizations</li>
    </ul>

    <div class="btn-row">
      <button class="btn" id="copy-script-btn">
        <span class="icon">üìã</span>
        <span>Copy Script</span>
      </button>
      <!-- You can change href to your own JupyterLite instance if needed -->
      <a class="btn secondary" id="jupyterlite-btn"
         href="https://jupyterlite.github.io/demo/lab/index.html"
         target="_blank" rel="noopener">
        <span class="icon">üß™</span>
        <span>Open in JupyterLite</span>
      </a>
    </div>

    <div class="script-shell">
      <div class="script-meta">
        <small>
          <strong>STUR-QC Lattice 1.0</strong> ¬∑ deterministic, no Born rule
        </small>
        <small>Tested for N = 6, XX+YY continuity, flux invariant</small>
      </div>
      <textarea id="python-script" readonly spellcheck="false">
#!/usr/bin/env python3
import numpy as np, math, json
from numpy.linalg import eig
from scipy.linalg import expm
import matplotlib.pyplot as plt

# Dark theme for STUR lab visuals
plt.style.use("dark_background")

# ============================================================
# STUR radial modulator
# ============================================================
def S_STUR(r, L0):
    x = r / L0
    return math.tanh(x) * (1.0 - math.exp(-x))

# Pauli / ladder operators
I2 = np.eye(2, dtype=complex)
sx = np.array([[0, 1],[1, 0]], dtype=complex)
sy = np.array([[0, -1j],[1j,  0]], dtype=complex)
sz = np.array([[1, 0],[0,-1]], dtype=complex)
s_plus  = np.array([[0, 1],[0, 0]], dtype=complex)
s_minus = np.array([[0, 0],[1, 0]], dtype=complex)

# ============================================================
# Tensor helpers
# ============================================================
def kron_all(ops):
    out = ops[0]
    for op in ops[1:]:
        out = np.kron(out, op)
    return out

def single_op(pauli, site, N):
    ops = [I2 for _ in range(N)]
    ops[site] = pauli
    return kron_all(ops)

def two_op(pauli_a, i, pauli_b, j, N):
    if i == j:
        raise ValueError("Sites i and j must be different.")
    ops = [I2 for _ in range(N)]
    ops[i] = pauli_a
    ops[j] = pauli_b
    return kron_all(ops)

# ============================================================
# STUR resistance generator R_STUR
# ============================================================
def build_R_STUR(N, L0=1.0, a_lat=1.0, h0=1.0, J0=1.0, Omega=0.5):
    """
    R_STUR =
      Œ£_i    h0 S(r_i) œÉ_z^i
    + Œ£_i<j J0 S(|r_i-r_j|)(œÉ_x^i œÉ_x^j + œÉ_y^i œÉ_y^j)
    + Œ© Œ£_i  S(r_i) œÉ_x^i
    """
    dim = 2**N
    R = np.zeros((dim, dim), dtype=complex)
    positions = np.array([i * a_lat for i in range(N)], dtype=float)

    # On-site STUR-weighted œÉ_z
    for i in range(N):
        r_i = positions[i]
        S_i = S_STUR(r_i, L0)
        h_i = h0 * S_i
        R += h_i * single_op(sz, i, N)

    # Pairwise STUR-weighted XX+YY couplings
    for i in range(N):
        for j in range(i + 1, N):
            r_ij = abs(positions[i] - positions[j])
            S_ij = S_STUR(r_ij, L0)
            J_ij = J0 * S_ij
            R += J_ij * (two_op(sx, i, sx, j, N) +
                         two_op(sy, i, sy, j, N))

    # STUR-weighted transverse drive
    for i in range(N):
        r_i = positions[i]
        S_i = S_STUR(r_i, L0)
        R += Omega * S_i * single_op(sx, i, N)

    return R, positions

# ============================================================
# Deterministic STUR evolution (no Born rule)
# ============================================================
def evolve_STUR(R, psi0, t_final, n_steps, hbar=1.0):
    """
    iƒß dŒ®/dt = R_STUR Œ®  (Œ® = STUR resistance field, not probability)
    """
    dt = t_final / n_steps
    U_dt = expm(-1j * R * dt / hbar)

    psi = psi0.copy()
    traj = [psi.copy()]
    for _ in range(n_steps):
        psi = U_dt @ psi
        psi /= np.linalg.norm(psi)   # numerical stabilization
        traj.append(psi.copy())
    return np.array(traj), dt

# ============================================================
# Entanglement entropy (information measure)
# ============================================================
def entanglement_entropy(psi, N, NA):
    NB = N - NA
    dimA = 2**NA
    dimB = 2**NB
    psi_mat = psi.reshape(dimA, dimB)
    rho_A = psi_mat @ psi_mat.conj().T

    vals, _ = eig(rho_A)
    vals = np.real_if_close(vals)
    vals = np.clip(vals, 0.0, 1.0)

    mask = vals > 1e-12
    lam = vals[mask]
    if lam.size == 0:
        return 0.0
    return float(-np.sum(lam * np.log2(lam)))

# ============================================================
# Global resistance-flux invariant
# ============================================================
def resistance_flux(psi, R):
    """
    Œ¶_R(Œ®) = Re[Œ®‚Ä† R Œ®]  (discrete ‚à´œÅ_R dV)
    """
    return float(np.real(np.vdot(psi, R @ psi)))

# ============================================================
# Local densities and bond currents
# ============================================================
def local_density_ops(N):
    """
    n_i = (1 - œÉ_z^i)/2  ‚Üí local excitation density
    """
    return [0.5 * (single_op(I2, i, N) - single_op(sz, i, N))
            for i in range(N)]

def local_densities(traj, n_ops):
    dens = []
    for psi in traj:
        dens.append([np.real(np.vdot(psi, op @ psi)) for op in n_ops])
    return np.array(dens)

def bond_currents(traj, N, positions, L0, J0):
    """
    J_{i‚Üíj}(t) = 4 J_ij Im <œÉ_i^+ œÉ_j^->
    with J_ij = J0 S(|r_i - r_j|; L0)
    """
    splus_ops  = {i: single_op(s_plus,  i, N) for i in range(N)}
    sminus_ops = {i: single_op(s_minus, i, N) for i in range(N)}

    currents = []
    for psi in traj:
        curMat = np.zeros((N, N))
        for i in range(N):
            for j in range(N):
                if i == j:
                    continue
                r_ij = abs(positions[i] - positions[j])
                S_ij = S_STUR(r_ij, L0)
                J_ij = J0 * S_ij
                op = splus_ops[i] @ sminus_ops[j]
                expv = np.vdot(psi, op @ psi)
                curMat[i, j] = 4.0 * J_ij * np.imag(expv)
        currents.append(curMat)
    return np.array(currents)

def continuity_max_residual(dens, currents, dt):
    """
    Check dœÅ_i/dt + Œ£_j J_{i‚Üíj} ‚âà 0 (central differences).
    """
    T, N = dens.shape[0], dens.shape[1]
    max_res = 0.0
    for t in range(1, T - 1):
        d_rho = (dens[t + 1] - dens[t - 1]) / (2.0 * dt)
        for i in range(N):
            sumJ = np.sum(currents[t][i, :])
            res = d_rho[i] + sumJ
            max_res = max(max_res, abs(res))
    return max_res

# ============================================================
# Plotting + JSON export
# ============================================================
def make_plots_and_json(dens, currents, dt, J_index=(0,1),
                        S_vals=None, flux_vals=None,
                        summary_path="stur_qc_summary.json"):
    T, N = dens.shape
    times = np.linspace(0.0, dt*(T-1), T)

    # --- 1) Density heatmap œÅ_i(t) ---------------------------------
    fig1, ax1 = plt.subplots()
    im = ax1.imshow(dens.T, aspect='auto', origin='lower',
                    extent=[times[0], times[-1], 0, N-1])
    ax1.set_xlabel("time (arb. units)")
    ax1.set_ylabel("site index i")
    ax1.set_title("STUR local density field $\\rho_i(t)$")
    fig1.colorbar(im, ax=ax1, label="$\\rho_i$")
    fig1.tight_layout()
    fig1.savefig("stur_qc_densities.png", dpi=200)

    # --- 2) Bond current J_{i‚Üíj}(t) + N_tot(t) ---------------------
    i, j = J_index
    J_ij_t = currents[:, i, j]
    N_tot = dens.sum(axis=1)

    fig2, ax2 = plt.subplots()
    ax2.plot(times, J_ij_t, label=f"J_{{{i}->{j}}}(t)")
    ax2.set_xlabel("time (arb. units)")
    ax2.set_ylabel("bond current")
    ax2.set_title("STUR bond current along lattice")
    ax2.legend(loc="upper right")
    ax2.grid(True, alpha=0.3)
    fig2.tight_layout()
    fig2.savefig("stur_qc_current.png", dpi=200)

    # --- 3) Global invariants: S_A(t), Œ¶_R(t) ----------------------
    if S_vals is not None or flux_vals is not None:
        fig3, ax3 = plt.subplots()
        if S_vals is not None:
            ax3.plot(times[:len(S_vals)], S_vals, label="S_A(t) [bits]")
        if flux_vals is not None:
            ax3.plot(times[:len(flux_vals)], flux_vals, linestyle="--",
                     label="Œ¶_R(t)")
        ax3.set_xlabel("time (arb. units)")
        ax3.set_title("STUR global invariants")
        ax3.grid(True, alpha=0.3)
        ax3.legend()
        fig3.tight_layout()
        fig3.savefig("stur_qc_globals.png", dpi=200)

    # --- JSON summary (GitHub/Zenodo metadata) ---------------------
    summary = {
        "N_sites": int(N),
        "T_steps": int(T),
        "dt": float(dt),
        "J_index": [int(i), int(j)],
        "density_min": float(dens.min()),
        "density_max": float(dens.max()),
        "current_min": float(J_ij_t.min()),
        "current_max": float(J_ij_t.max()),
        "N_tot_min": float(N_tot.min()),
        "N_tot_max": float(N_tot.max())
    }
    if S_vals is not None:
        summary["S_A_max_bits"] = float(max(S_vals))
        summary["S_A_final_bits"] = float(S_vals[-1])
    if flux_vals is not None:
        summary["Phi_R_min"] = float(min(flux_vals))
        summary["Phi_R_max"] = float(max(flux_vals))
    with open(summary_path, "w") as f:
        json.dump(summary, f, indent=2)

# ============================================================
# Main: STUR QC run + continuity + plots
# ============================================================
if __name__ == "__main__":
    # --- Core STUR QC run (entanglement + flux) --------------------
    N    = 6
    NA   = 3
    L0   = 1.0
    a_lat = 1.0
    h0   = 1.0
    J0   = 0.8
    Omega = 0.6
    t_final = 5.0
    n_steps = 200
    dim = 2**N

    print(f"Building full STUR operator for N={N} (dim={dim})...")
    R_full, positions = build_R_STUR(N, L0, a_lat, h0, J0, Omega)

    psi0 = np.zeros(dim, dtype=complex)
    psi0[0] = 1.0
    print("Evolving deterministic STUR field (full R_STUR)...")
    traj_full, dt_full = evolve_STUR(R_full, psi0, t_final, n_steps)

    S_vals = [entanglement_entropy(psi, N, NA) for psi in traj_full]
    flux_vals = [resistance_flux(psi, R_full) for psi in traj_full]
    print(f"Max entanglement S_A = {max(S_vals):.4f} bits")
    print(f"Final entanglement S_A(T) = {S_vals[-1]:.4f} bits")

    flux0 = flux_vals[0]
    drift_abs = max(flux_vals) - min(flux_vals)
    drift_rel = drift_abs / (abs(flux0) + 1e-15)
    print("\nResistance-flux invariant Œ¶_R(t):")
    print(f"  Œ¶_R(0)        = {flux0:.10f}")
    print(f"  min / max     = {min(flux_vals):.10f} / {max(flux_vals):.10f}")
    print(f"  |ŒîŒ¶_R|        = {drift_abs:.3e}")
    print(f"  relative drift= {drift_rel:.3e}")

    # --- Continuity / flow visualization run -----------------------
    print("\n=== Local continuity + flow visualization run ===")
    R_xx, positions = build_R_STUR(N, L0, a_lat, h0=0.0, J0=J0, Omega=0.0)

    # Single excitation at site 0 ‚Üí watch it flow
    psi0_cont = np.zeros(dim, dtype=complex)
    psi0_cont[1] = 1.0
    t_final_c = 1.0
    n_steps_c = 400

    print("Evolving XX+YY-only STUR lattice...")
    traj_c, dt_c = evolve_STUR(R_xx, psi0_cont, t_final_c, n_steps_c)

    n_ops = local_density_ops(N)
    dens = local_densities(traj_c, n_ops)
    currents = bond_currents(traj_c, N, positions, L0, J0)

    max_res = continuity_max_residual(dens, currents, dt_c)
    N_tot = dens.sum(axis=1)
    N_drift = float(N_tot.max() - N_tot.min())
    print(f"  Max |dœÅ_i/dt + Œ£_j J_i‚Üíj| = {max_res:.3e}")
    print(f"  Total excitation drift   = {N_drift:.3e}")

    print("\nRendering STUR flow plots + JSON summary...")
    make_plots_and_json(dens, currents, dt_c, J_index=(0,1),
                        S_vals=S_vals, flux_vals=flux_vals)
    print("Saved: stur_qc_densities.png, stur_qc_current.png,")
    print("       stur_qc_globals.png,  stur_qc_summary.json")
      </textarea>
    </div>

    <div class="badge-row">
      <div class="badge">Fully deterministic STUR evolution</div>
      <div class="badge">No Born-rule probabilities</div>
      <div class="badge">Flux &amp; continuity invariants verified</div>
      <div class="badge">Ready for JupyterLite / Python 3</div>
    </div>
  </section>

</main>

<!-- JSON loader + copy-to-clipboard logic -->
<script>
  // Load JSON summary if available
  (function () {
    var pre = document.getElementById("json-summary");
    fetch("stur_qc_summary.json")
      .then(function (r) {
        if (!r.ok) throw new Error("HTTP " + r.status);
        return r.json();
      })
      .then(function (data) {
        pre.textContent = JSON.stringify(data, null, 2);
      })
      .catch(function () {
        pre.textContent = "Could not load stur_qc_summary.json.\n"
          + "Ensure it is in the same directory as this HTML file.";
      });
  })();

  // Copy script button
  document.getElementById("copy-script-btn").addEventListener("click", function () {
    var ta = document.getElementById("python-script");
    ta.select();
    ta.setSelectionRange(0, 9999999);
    try {
      var ok = document.execCommand("copy");
      if (!ok && navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(ta.value);
      }
      this.textContent = "Copied!";
      var btn = this;
      setTimeout(function () { btn.textContent = "Copy Script"; }, 1200);
    } catch (e) {
      alert("Copy failed. Manually select and copy the script.");
    }
  });
</script>

</body>
</html>
