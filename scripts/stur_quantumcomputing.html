<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STUR QC – Resistance Flow & Continuity Verifier</title>
<style>
  body{
    background:#050814;
    color:#e6edf3;
    font-family:"Courier New",monospace;
    margin:0;
    padding:2rem;
  }
  h1{color:#ffaa00;text-align:center;}
  h2{color:#ffcc33;margin-top:2rem;}
  .desc{
    max-width:960px;
    margin:0 auto 1.5rem auto;
    line-height:1.6;
  }
  pre{
    background:#0a0f1f;
    color:#00ffcc;
    padding:1rem;
    border-radius:8px;
    overflow-x:auto;
    font-size:0.86rem;
    box-shadow:0 0 18px #ffaa0040;
  }
  button{
    background:#ffaa00;
    color:#050814;
    border:none;
    border-radius:6px;
    padding:10px 20px;
    font-weight:bold;
    cursor:pointer;
    margin:6px;
    transition:0.2s;
  }
  button:hover{background:#ffcc33;}
  footer{
    text-align:center;
    font-size:0.9em;
    color:#999;
    margin-top:2rem;
  }
  a{color:#66ccff;}
  .center{text-align:center;margin-top:1rem;}
</style>
</head>
<body>

<h1>STUR QC – Resistance Flow &amp; Continuity Verifier</h1>

<div class="desc">
<p>
This simulation tests whether a <b>STUR resistance generator</b> can act as a deterministic quantum-like lattice engine,
preserving continuity and entanglement without invoking the Born rule.
It evolves the full operator R<sub>STUR</sub> and checks information flow through
the discrete continuity law:
</p>

<p style="text-align:center;">
dρ<sub>i</sub>/dt + Σ<sub>j</sub> J<sub>i→j</sub> ≈ 0.
</p>

<p>
Outputs include:
<ul>
<li><code>stur_qc_densities.png</code> – density ρ<sub>i</sub>(t)</li>
<li><code>stur_qc_current.png</code> – bond current trace</li>
<li><code>stur_qc_globals.png</code> – S<sub>A</sub>(t) and Φ<sub>R</sub>(t)</li>
<li><code>stur_qc_summary.json</code> – metadata for GitHub/Zenodo</li>
</ul>
</p>

<p>
Copy the script below and paste it into a JupyterLite notebook (Python 3 + NumPy + SciPy + Matplotlib) to run the full deterministic STUR QC test.
</p>
</div>

<h2>Python Simulation (copy &amp; run)</h2>

<pre id="codeBlock">#!/usr/bin/env python3
import numpy as np, math, json
from numpy.linalg import eig
from scipy.linalg import expm
import matplotlib.pyplot as plt

plt.style.use("dark_background")

def S_STUR(r, L0):
    x = r / L0
    return math.tanh(x) * (1.0 - math.exp(-x))

I2 = np.eye(2, dtype=complex)
sx = np.array([[0,1],[1,0]],dtype=complex)
sy = np.array([[0,-1j],[1j,0]],dtype=complex)
sz = np.array([[1,0],[0,-1]],dtype=complex)
s_plus  = np.array([[0,1],[0,0]],dtype=complex)
s_minus = np.array([[0,0],[1,0]],dtype=complex)

def kron_all(ops):
    out=ops[0]
    for op in ops[1:]: out=np.kron(out,op)
    return out

def single_op(pauli,site,N):
    ops=[I2 for _ in range(N)]
    ops[site]=pauli
    return kron_all(ops)

def two_op(pauli_a,i,pauli_b,j,N):
    ops=[I2 for _ in range(N)]
    ops[i]=pauli_a; ops[j]=pauli_b
    return kron_all(ops)

def build_R_STUR(N,L0=1,a_lat=1,h0=1,J0=1,Omega=0.5):
    dim=2**N; R=np.zeros((dim,dim),dtype=complex)
    pos=np.array([i*a_lat for i in range(N)],float)
    for i in range(N):
        S_i=S_STUR(pos[i],L0)
        R+=h0*S_i*single_op(sz,i,N)
    for i in range(N):
        for j in range(i+1,N):
            r_ij=abs(pos[i]-pos[j])
            S_ij=S_STUR(r_ij,L0)
            R+=J0*S_ij*(two_op(sx,i,sx,j,N)+two_op(sy,i,sy,j,N))
    for i in range(N):
        S_i=S_STUR(pos[i],L0)
        R+=Omega*S_i*single_op(sx,i,N)
    return R,pos

def evolve_STUR(R,psi0,t_final,n_steps,hbar=1):
    dt=t_final/n_steps; U=expm(-1j*R*dt/hbar)
    psi=psi0.copy(); traj=[psi.copy()]
    for _ in range(n_steps):
        psi=U@psi; psi/=np.linalg.norm(psi)
        traj.append(psi.copy())
    return np.array(traj),dt

def entanglement_entropy(psi,N,NA):
    NB=N-NA; dimA=2**NA; dimB=2**NB
    psiM=psi.reshape(dimA,dimB)
    rhoA=psiM@psiM.conj().T
    vals,_=eig(rhoA)
    vals=np.clip(np.real_if_close(vals),0,1)
    vals=vals[vals>1e-12]
    return float(-np.sum(vals*np.log2(vals))) if vals.size else 0

def resistance_flux(psi,R):
    return float(np.real(np.vdot(psi,R@psi)))

def local_density_ops(N):
    return [0.5*(single_op(I2,i,N)-single_op(sz,i,N)) for i in range(N)]

def local_densities(traj,ops):
    return np.array([[np.real(np.vdot(p,o@p)) for o in ops] for p in traj])

def bond_currents(traj,N,pos,L0,J0):
    splus={i:single_op(s_plus,i,N) for i in range(N)}
    sminus={i:single_op(s_minus,i,N) for i in range(N)}
    cur=[]
    for psi in traj:
        M=np.zeros((N,N))
        for i in range(N):
            for j in range(N):
                if i==j: continue
                r=abs(pos[i]-pos[j]); S=S_STUR(r,L0)
                J=J0*S; op=splus[i]@sminus[j]
                M[i,j]=4*J*np.imag(np.vdot(psi,op@psi))
        cur.append(M)
    return np.array(cur)

def continuity_max_residual(dens,cur,dt):
    T,N=dens.shape; m=0
    for t in range(1,T-1):
        d=(dens[t+1]-dens[t-1])/(2*dt)
        for i in range(N):
            s=np.sum(cur[t][i,:]); m=max(m,abs(d[i]+s))
    return m

def make_plots_and_json(dens,cur,dt,J_index=(0,1),
                        S_vals=None,flux_vals=None,
                        path="stur_qc_summary.json"):
    T,N=dens.shape; times=np.linspace(0,dt*(T-1),T)
    fig1,ax1=plt.subplots()
    im=ax1.imshow(dens.T,aspect='auto',origin='lower',
                  extent=[times[0],times[-1],0,N-1])
    ax1.set_xlabel("time"); ax1.set_ylabel("site i")
    ax1.set_title("STUR local density ρᵢ(t)")
    fig1.colorbar(im,ax=ax1,label="ρᵢ")
    fig1.tight_layout(); fig1.savefig("stur_qc_densities.png",dpi=200)

    i,j=J_index; Jt=cur[:,i,j]; Ntot=dens.sum(1)
    fig2,ax2=plt.subplots()
    ax2.plot(times,Jt,label=f"J_{i}->{j}(t)")
    ax2.set_xlabel("time"); ax2.set_ylabel("bond current")
    ax2.set_title("STUR bond current"); ax2.legend(); ax2.grid(True,alpha=.3)
    fig2.tight_layout(); fig2.savefig("stur_qc_current.png",dpi=200)

    if S_vals or flux_vals:
        fig3,ax3=plt.subplots()
        if S_vals: ax3.plot(times[:len(S_vals)],S_vals,label="S_A (bits)")
        if flux_vals: ax3.plot(times[:len(flux_vals)],flux_vals,"--",label="Φ_R")
        ax3.set_xlabel("time"); ax3.set_title("STUR global invariants")
        ax3.legend(); ax3.grid(True,alpha=.3)
        fig3.tight_layout(); fig3.savefig("stur_qc_globals.png",dpi=200)

    summary={"N_sites":int(N),"T_steps":int(T),"dt":float(dt),
             "J_index":[int(i),int(j)],
             "density_min":float(dens.min()),"density_max":float(dens.max()),
             "current_min":float(Jt.min()),"current_max":float(Jt.max()),
             "N_tot_min":float(Ntot.min()),"N_tot_max":float(Ntot.max())}
    if S_vals:
        summary["S_A_max_bits"]=float(max(S_vals))
        summary["S_A_final_bits"]=float(S_vals[-1])
    if flux_vals:
        summary["Phi_R_min"]=float(min(flux_vals))
        summary["Phi_R_max"]=float(max(flux_vals))
    with open(path,"w") as f: json.dump(summary,f,indent=2)

if __name__=="__main__":
    N=6; NA=3; L0=1; a_lat=1; h0=1; J0=0.8; Omega=0.6
    t_final=5; n_steps=200; dim=2**N
    print(f"Building R_STUR for N={N}, dim={dim}...")
    R, pos = build_R_STUR(N,L0,a_lat,h0,J0,Omega)
    psi0=np.zeros(dim,complex); psi0[0]=1
    traj,dt=evolve_STUR(R,psi0,t_final,n_steps)
    S_vals=[entanglement_entropy(p,N,NA) for p in traj]
    flux=[resistance_flux(p,R) for p in traj]
    print(f"Max S_A = {max(S_vals):.3f} bits")
    print(f"Φ_R drift = {max(flux)-min(flux):.3e}")

    print("\n=== Continuity test ===")
    R_xx,_=build_R_STUR(N,L0,a_lat,0,J0,0)
    psi1=np.zeros(dim,complex); psi1[1]=1
    traj2,dt2=evolve_STUR(R_xx,psi1,1.0,400)
    dens=local_densities(traj2,local_density_ops(N))
    cur=bond_currents(traj2,N,pos,L0,J0)
    res=continuity_max_residual(dens,cur,dt2)
    print(f"Max |dρ/dt+ΣJ| = {res:.3e}")
    make_plots_and_json(dens,cur,dt2,S_vals=S_vals,flux_vals=flux)
    print("Saved STUR QC plots + stur_qc_summary.json")</pre>

<div class="center">
  <button onclick="copyCode()">Copy Python Script</button>
  <button onclick="openJupyter()">Open JupyterLite</button>
</div>

<footer>
&copy; 2025 Sheldon Lon Lindberg • STUR Physics Framework • CC-BY 4.0 License
</footer>

<script>
function copyCode(){
  const code=document.getElementById("codeBlock").innerText;
  navigator.clipboard.writeText(code);
  alert("STUR QC script copied to clipboard.");
}
function openJupyter(){
  window.open("https://jupyter.org/try-jupyter/lab/","_blank");
}
</script>
</body>
</html>
