<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>STUR QC – Resistance Flow & Continuity</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<style>
  :root{
    --bg:#020817;
    --panel:#050b18;
    --accent:#00e0ff;
    --accent2:#ffaa00;
    --text:#e6edf3;
    --muted:#9ca3af;
  }
  *{box-sizing:border-box;}
  body{
    margin:0;
    padding:2rem 1.5rem 3rem;
    background:radial-gradient(circle at top,#071021 0,#020817 55%,#000 100%);
    color:var(--text);
    font-family:system-ui,-apple-system,BlinkMacSystemFont,"SF Pro Text","Segoe UI",sans-serif;
  }
  h1{
    text-align:center;
    color:var(--accent2);
    letter-spacing:0.04em;
    text-transform:uppercase;
    font-size:1.4rem;
    margin-bottom:0.4rem;
  }
  h2{
    color:var(--accent);
    margin-top:1.8rem;
    font-size:1.05rem;
  }
  .subtitle{
    text-align:center;
    color:var(--muted);
    font-size:0.9rem;
    margin-bottom:1.8rem;
  }
  .shell{
    max-width:980px;
    margin:0 auto;
  }
  .card{
    background:linear-gradient(145deg,#050b18,#020715);
    border-radius:14px;
    border:1px solid rgba(148,163,184,0.35);
    box-shadow:0 0 35px rgba(15,23,42,0.9);
    padding:1.4rem 1.4rem 1.6rem;
    margin-bottom:1.8rem;
  }
  .card h2:first-child{margin-top:0;}
  p{line-height:1.55;font-size:0.96rem;}
  ul{line-height:1.5;font-size:0.95rem;margin-top:0.4rem;}
  code.inline{
    font-family:"SF Mono","Menlo","Consolas",monospace;
    background:#020617;
    padding:0 0.25rem;
    border-radius:4px;
    font-size:0.9em;
    color:#7ee0ff;
  }
  pre{
    background:#020617;
    border-radius:10px;
    padding:1rem 1.1rem;
    overflow-x:auto;
    font-size:0.82rem;
    line-height:1.45;
    color:#e5f2ff;
    font-family:"SF Mono","Menlo","Consolas",monospace;
    box-shadow:0 0 25px rgba(56,189,248,0.25);
    border:1px solid rgba(148,163,184,0.55);
    white-space:pre;
  }
  .btn-row{
    display:flex;
    flex-wrap:wrap;
    gap:0.6rem;
    margin:0.4rem 0 1.0rem;
  }
  button,a.btn{
    display:inline-flex;
    align-items:center;
    justify-content:center;
    border:none;
    border-radius:999px;
    padding:0.45rem 0.95rem;
    font-size:0.86rem;
    font-weight:600;
    cursor:pointer;
    text-decoration:none;
    transition:all 0.15s ease-out;
    letter-spacing:0.03em;
  }
  button.primary,a.btn.primary{
    background:linear-gradient(135deg,#facc15,#f97316);
    color:#111827;
    box-shadow:0 0 16px rgba(250,204,21,0.35);
  }
  button.primary:hover,a.btn.primary:hover{
    transform:translateY(-1px);
    box-shadow:0 0 22px rgba(250,204,21,0.55);
  }
  button.secondary,a.btn.secondary{
    background:rgba(15,23,42,0.85);
    color:var(--accent);
    border:1px solid rgba(148,163,184,0.6);
  }
  button.secondary:hover,a.btn.secondary:hover{
    border-color:var(--accent);
    box-shadow:0 0 14px rgba(56,189,248,0.35);
  }
  .note{
    font-size:0.86rem;
    color:var(--muted);
    margin-top:0.4rem;
  }
  footer{
    margin-top:2.2rem;
    text-align:center;
    font-size:0.8rem;
    color:var(--muted);
  }
</style>
</head>
<body>
<div class="shell">
  <h1>STUR QC – Resistance Flow &amp; Continuity</h1>
  <div class="subtitle">
    STUR unified resistance on a finite spin chain, with local continuity and global invariants,
    Inspired by Lucas Nash X@lukenash.
  </div>

  <div class="card">
    <h2>Derivation Sketch – STUR Resistance Generator</h2>
    <p>
      We treat a chain of <code class="inline">N</code> two-level sites as an effective
      STUR medium. On each site <code class="inline">i</code> we place Pauli operators
      <code class="inline">σ<sub>x</sub><sup>i</sup>, σ<sub>y</sub><sup>i</sup>, σ<sub>z</sub><sup>i</sup></code>.
      The STUR radial modulator is
      </p>
      <p style="margin-left:0.5rem;">
        <code class="inline">S(r;L₀) = tanh(r/L₀) · (1 − exp(−r/L₀))</code>,
      </p>
      <p>
      which suppresses short-range response and saturates for large separation,
      just like in your other STUR sims.
    </p>
    <p>
      The effective STUR “resistance generator” is
    </p>
    <pre>R_STUR =
  Σᵢ   h₀ S(rᵢ;L₀) σᶻᵢ
+ Σᵢ&lt;j J₀ S(|rᵢ−rⱼ|;L₀) (σˣᵢ σˣⱼ + σʸᵢ σʸⱼ)
+ Ω Σᵢ S(rᵢ;L₀) σˣᵢ</pre>
    <p>
      We evolve a complex field <code class="inline">Ψ(t)</code> on the 2ᴺ-dimensional
      Hilbert space using a deterministic STUR equation
    </p>
    <pre>i ħ ∂ₜ Ψ(t) = R_STUR Ψ(t)</pre>
    <p>
      interpreted as a resistance-flow law, not as a probability rule.
      From <code class="inline">Ψ(t)</code> we compute:
    </p>
    <ul>
      <li><strong>Local density</strong> on each site:
        <code class="inline">nᵢ = (1 − σᶻᵢ)/2</code>, with density
        <code class="inline">ρᵢ(t) = ⟨Ψ|nᵢ|Ψ⟩</code>.</li>
      <li><strong>Bond currents</strong> between sites:
        <code class="inline">Jᵢ→ⱼ(t) = 4 Jᵢⱼ Im⟨σ⁺ᵢ σ⁻ⱼ⟩</code>,
        where <code class="inline">Jᵢⱼ = J₀ S(|rᵢ−rⱼ|;L₀)</code>.</li>
      <li><strong>Continuity residual</strong> from the lattice continuity equation
        <code class="inline">dρᵢ/dt + Σⱼ Jᵢ→ⱼ ≈ 0</code>.</li>
      <li><strong>Entanglement entropy</strong> <code class="inline">S_A(t)</code> of a block
        of <code class="inline">N_A</code> sites.</li>
      <li><strong>Global resistance flux</strong>
        <code class="inline">Φ_R(t) = Re[Ψ† R_STUR Ψ]</code>, which is
        approximately invariant if the STUR generator is well-behaved.</li>
    </ul>
    <p>
      The simulation below:
    </p>
    <ul>
      <li>Builds <code class="inline">R_STUR</code> for <code class="inline">N=6</code>.</li>
      <li>Evolves the full field and tracks <code class="inline">S_A(t)</code>
          and <code class="inline">Φ_R(t)</code>.</li>
      <li>Runs a second evolution with a single excitation,
          computes <code class="inline">ρᵢ(t)</code> and
          <code class="inline">Jᵢ→ⱼ(t)</code>, and checks continuity.</li>
      <li>Writes a JSON summary so the run can be archived alongside
          your Zenodo STUR series.</li>
    </ul>
  </div>

  <div class="card">
    <h2>Python Simulation (copy into JupyterLite)</h2>
    <div class="btn-row">
      <button class="primary" onclick="copySTURCode()">Copy STUR QC Script</button>
      <a class="secondary btn" href="https://jupyterlite.github.io/demo/lab/" target="_blank" rel="noopener">
        Open JupyterLite
      </a>
    </div>
    <p class="note">
      Paste the script below into a new notebook cell in JupyterLite and run it.
      It will generate three PNG plots and a JSON file
      <code class="inline">stur_qc_summary.json</code>.
    </p>
    <pre id="stur-code">
#!/usr/bin/env python3
import numpy as np, math, json
from numpy.linalg import eig
from scipy.linalg import expm
import matplotlib.pyplot as plt

# Dark theme for STUR lab visuals
plt.style.use("dark_background")

# ============================================================
# STUR radial modulator
# ============================================================
def S_STUR(r, L0):
    x = r / L0
    return math.tanh(x) * (1.0 - math.exp(-x))

# Pauli / ladder operators
I2 = np.eye(2, dtype=complex)
sx = np.array([[0, 1],[1, 0]], dtype=complex)
sy = np.array([[0, -1j],[1j,  0]], dtype=complex)
sz = np.array([[1, 0],[0,-1]], dtype=complex)
s_plus  = np.array([[0, 1],[0, 0]], dtype=complex)
s_minus = np.array([[0, 0],[1, 0]], dtype=complex)

# ============================================================
# Tensor helpers
# ============================================================
def kron_all(ops):
    out = ops[0]
    for op in ops[1:]:
        out = np.kron(out, op)
    return out

def single_op(pauli, site, N):
    ops = [I2 for _ in range(N)]
    ops[site] = pauli
    return kron_all(ops)

def two_op(pauli_a, i, pauli_b, j, N):
    if i == j:
        raise ValueError("Sites i and j must be different.")
    ops = [I2 for _ in range(N)]
    ops[i] = pauli_a
    ops[j] = pauli_b
    return kron_all(ops)

# ============================================================
# STUR resistance generator R_STUR
# ============================================================
def build_R_STUR(N, L0=1.0, a_lat=1.0, h0=1.0, J0=1.0, Omega=0.5):
    """
    R_STUR =
      Σ_i    h0 S(r_i) σ_z^i
    + Σ_i&lt;j J0 S(|r_i-r_j|)(σ_x^i σ_x^j + σ_y^i σ_y^j)
    + Ω Σ_i  S(r_i) σ_x^i
    """
    dim = 2**N
    R = np.zeros((dim, dim), dtype=complex)
    positions = np.array([i * a_lat for i in range(N)], dtype=float)

    # On-site STUR-weighted σ_z
    for i in range(N):
        r_i = positions[i]
        S_i = S_STUR(r_i, L0)
        h_i = h0 * S_i
        R += h_i * single_op(sz, i, N)

    # Pairwise STUR-weighted XX+YY couplings
    for i in range(N):
        for j in range(i + 1, N):
            r_ij = abs(positions[i] - positions[j])
            S_ij = S_STUR(r_ij, L0)
            J_ij = J0 * S_ij
            R += J_ij * (two_op(sx, i, sx, j, N) +
                         two_op(sy, i, sy, j, N))

    # STUR-weighted transverse drive
    for i in range(N):
        r_i = positions[i]
        S_i = S_STUR(r_i, L0)
        R += Omega * S_i * single_op(sx, i, N)

    return R, positions

# ============================================================
# Deterministic STUR evolution (no Born rule)
# ============================================================
def evolve_STUR(R, psi0, t_final, n_steps, hbar=1.0):
    """
    iħ dΨ/dt = R_STUR Ψ  (Ψ = STUR resistance field, not probability)
    """
    dt = t_final / n_steps
    U_dt = expm(-1j * R * dt / hbar)

    psi = psi0.copy()
    traj = [psi.copy()]
    for _ in range(n_steps):
        psi = U_dt @ psi
        psi /= np.linalg.norm(psi)   # numerical stabilization
        traj.append(psi.copy())
    return np.array(traj), dt

# ============================================================
# Entanglement entropy (information measure)
# ============================================================
def entanglement_entropy(psi, N, NA):
    NB = N - NA
    dimA = 2**NA
    dimB = 2**NB
    psi_mat = psi.reshape(dimA, dimB)
    rho_A = psi_mat @ psi_mat.conj().T

    vals, _ = eig(rho_A)
    vals = np.real_if_close(vals)
    vals = np.clip(vals, 0.0, 1.0)

    mask = vals > 1e-12
    lam = vals[mask]
    if lam.size == 0:
        return 0.0
    return float(-np.sum(lam * np.log2(lam)))

# ============================================================
# Global resistance-flux invariant
# ============================================================
def resistance_flux(psi, R):
    """
    Φ_R(Ψ) = Re[Ψ† R Ψ]  (discrete ∫ρ_R dV)
    """
    return float(np.real(np.vdot(psi, R @ psi)))

# ============================================================
# Local densities and bond currents
# ============================================================
def local_density_ops(N):
    """
    n_i = (1 - σ_z^i)/2  → local excitation density
    """
    return [0.5 * (single_op(I2, i, N) - single_op(sz, i, N))
            for i in range(N)]

def local_densities(traj, n_ops):
    dens = []
    for psi in traj:
        dens.append([np.real(np.vdot(psi, op @ psi)) for op in n_ops])
    return np.array(dens)

def bond_currents(traj, N, positions, L0, J0):
    """
    J_{i→j}(t) = 4 J_ij Im <σ_i^+ σ_j^->
    with J_ij = J0 S(|r_i - r_j|; L0)
    """
    splus_ops  = {i: single_op(s_plus,  i, N) for i in range(N)}
    sminus_ops = {i: single_op(s_minus, i, N) for i in range(N)}

    currents = []
    for psi in traj:
        curMat = np.zeros((N, N))
        for i in range(N):
            for j in range(N):
                if i == j:
                    continue
                r_ij = abs(positions[i] - positions[j])
                S_ij = S_STUR(r_ij, L0)
                J_ij = J0 * S_ij
                op = splus_ops[i] @ sminus_ops[j]
                expv = np.vdot(psi, op @ psi)
                curMat[i, j] = 4.0 * J_ij * np.imag(expv)
        currents.append(curMat)
    return np.array(currents)

def continuity_max_residual(dens, currents, dt):
    """
    Check dρ_i/dt + Σ_j J_{i→j} ≈ 0 (central differences).
    """
    T, N = dens.shape[0], dens.shape[1]
    max_res = 0.0
    for t in range(1, T - 1):
        d_rho = (dens[t + 1] - dens[t - 1]) / (2.0 * dt)
        for i in range(N):
            sumJ = np.sum(currents[t][i, :])
            res = d_rho[i] + sumJ
            max_res = max(max_res, abs(res))
    return max_res

# ============================================================
# Plotting + JSON export
# ============================================================
def make_plots_and_json(dens, currents, dt, J_index=(0,1),
                        S_vals=None, flux_vals=None,
                        summary_path="stur_qc_summary.json"):
    T, N = dens.shape
    times = np.linspace(0.0, dt*(T-1), T)

    # --- 1) Density heatmap ρ_i(t) ---------------------------------
    fig1, ax1 = plt.subplots()
    im = ax1.imshow(dens.T, aspect='auto', origin='lower',
                    extent=[times[0], times[-1], 0, N-1])
    ax1.set_xlabel("time")
    ax1.set_ylabel("site")
    ax1.set_title("STUR local density ρ(t)")
    fig1.colorbar(im, ax=ax1, label="ρᵢ")
    fig1.tight_layout()
    fig1.savefig("stur_qc_densities.png", dpi=200)

    # --- 2) Bond current J_{i→j}(t) + N_tot(t) ---------------------
    i, j = J_index
    J_ij_t = currents[:, i, j]
    N_tot = dens.sum(axis=1)

    fig2, ax2 = plt.subplots()
    ax2.plot(times, J_ij_t, label=f"J_{i}->{j}(t)")
    ax2.set_xlabel("time")
    ax2.set_ylabel("bond current")
    ax2.set_title("STUR bond current")
    ax2.grid(True, alpha=0.3)
    ax2.legend(loc="upper right")
    fig2.tight_layout()
    fig2.savefig("stur_qc_current.png", dpi=200)

    # --- 3) Global invariants: S_A(t), Φ_R(t) ----------------------
    if S_vals is not None or flux_vals is not None:
        fig3, ax3 = plt.subplots()
        if S_vals is not None:
            ax3.plot(times[:len(S_vals)], S_vals, label="S_A (bits)")
        if flux_vals is not None:
            ax3.plot(times[:len(flux_vals)], flux_vals, linestyle="--",
                     label="Φ_R")
        ax3.set_xlabel("time")
        ax3.set_title("STUR global invariants")
        ax3.grid(True, alpha=0.3)
        ax3.legend()
        fig3.tight_layout()
        fig3.savefig("stur_qc_globals.png", dpi=200)

    # --- JSON summary ----------------------------------------------
    summary = {
        "N_sites": int(N),
        "T_steps": int(T),
        "dt": float(dt),
        "J_index": [int(i), int(j)],
        "density_min": float(dens.min()),
        "density_max": float(dens.max()),
        "current_min": float(J_ij_t.min()),
        "current_max": float(J_ij_t.max()),
        "N_tot_min": float(N_tot.min()),
        "N_tot_max": float(N_tot.max())
    }
    if S_vals is not None:
        summary["S_A_max_bits"] = float(max(S_vals))
        summary["S_A_final_bits"] = float(S_vals[-1])
    if flux_vals is not None:
        summary["Phi_R_min"] = float(min(flux_vals))
        summary["Phi_R_max"] = float(max(flux_vals))
    with open(summary_path, "w") as f:
        json.dump(summary, f, indent=2)

# ============================================================
# Main: STUR QC run + continuity + plots
# ============================================================
if __name__ == "__main__":
    # --- Core STUR QC run (entanglement + flux) --------------------
    N      = 6
    NA     = 3
    L0     = 1.0
    a_lat  = 1.0
    h0     = 1.0
    J0     = 0.8
    Omega  = 0.6
    t_final = 5.0
    n_steps = 200
    dim    = 2**N

    print(f"Building full R_STUR for N={N} (dim={dim})...")
    R_full, positions = build_R_STUR(N, L0, a_lat, h0, J0, Omega)

    psi0 = np.zeros(dim, dtype=complex)
    psi0[0] = 1.0
    print("Evolving deterministic STUR field (full R_STUR)...")
    traj_full, dt_full = evolve_STUR(R_full, psi0, t_final, n_steps)

    S_vals    = [entanglement_entropy(psi, N, NA) for psi in traj_full]
    flux_vals = [resistance_flux(psi, R_full) for psi in traj_full]
    print(f"Max entanglement S_A = {max(S_vals):.4f} bits")
    print(f"Final entanglement S_A(T) = {S_vals[-1]:.4f} bits")

    flux0 = flux_vals[0]
    drift_abs = max(flux_vals) - min(flux_vals)
    drift_rel = drift_abs / (abs(flux0) + 1e-15)
    print("\nΦ_R invariant:")
    print(f"  Φ_R(0)        = {flux0:.10e}")
    print(f"  min / max     = {min(flux_vals):.10e} / {max(flux_vals):.10e}")
    print(f"  |ΔΦ_R|        = {drift_abs:.3e}")
    print(f"  relative drift= {drift_rel:.3e}")

    # --- Continuity / flow visualization run -----------------------
    print("\n=== Continuity test ===")
    R_xx, positions = build_R_STUR(N, L0, a_lat, h0=0.0, J0=J0, Omega=0.0)

    psi0_cont = np.zeros(dim, dtype=complex)
    psi0_cont[1] = 1.0          # local excitation at site 0
    t_final_c = 1.0
    n_steps_c = 400

    print("Evolving XX+YY-only STUR lattice...")
    traj_c, dt_c = evolve_STUR(R_xx, psi0_cont, t_final_c, n_steps_c)

    n_ops   = local_density_ops(N)
    dens    = local_densities(traj_c, n_ops)
    currents = bond_currents(traj_c, N, positions, L0, J0)

    max_res = continuity_max_residual(dens, currents, dt_c)
    N_tot   = dens.sum(axis=1)
    N_drift = float(N_tot.max() - N_tot.min())
    print(f"Max |dρ_i/dt + Σ_j J_i→j| = {max_res:.3e}")
    print(f"Total excitation drift   = {N_drift:.3e}")

    print("\nRendering STUR QC plots + JSON summary...")
    make_plots_and_json(dens, currents, dt_c,
                        J_index=(0,1),
                        S_vals=S_vals,
                        flux_vals=flux_vals)
    print("Saved STUR QC plots + stur_qc_summary.json")
</pre>
  </div>

  <div class="card">
    <h2>Outputs</h2>
    <p>
      When you run the script in JupyterLite, it will generate:
    </p>
    <ul>
      <li><code class="inline">stur_qc_densities.png</code> — heatmap of
          local densities <code class="inline">ρᵢ(t)</code> across the chain.</li>
      <li><code class="inline">stur_qc_current.png</code> — bond current
          <code class="inline">J₀→₁(t)</code> vs time.</li>
      <li><code class="inline">stur_qc_globals.png</code> — entanglement
          <code class="inline">S_A(t)</code> and resistance flux
          <code class="inline">Φ_R(t)</code>.</li>
      <li><code class="inline">stur_qc_summary.json</code> — numeric summary for
          archiving and cross-checking with other STUR sims.</li>
    </ul>
  </div>

  <footer>
    STUR Physics Lab – STUR QC Resistance Flow • HTML shell generated for direct use with JupyterLite.
  </footer>
</div>

<script>
function copySTURCode(){
  const el = document.getElementById("stur-code");
  if(!el) return;
  const text = el.innerText;
  navigator.clipboard.writeText(text).then(
    () => { console.log("STUR QC script copied."); },
    () => { console.warn("Clipboard copy failed."); }
  );
}
</script>
</body>
</html>
