<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>STUR 5D Helical Manifold Lab â€“ v4.0</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  :root {
    --bg-main: #02030a;
    --bg-panel: #050816;
    --bg-panel-soft: #07101e;
    --accent: #34d8ff;
    --accent-soft: rgba(52, 216, 255, 0.2);
    --accent-strong: #00f2aa;
    --text-main: #e6edf3;
    --text-soft: #a5b3c4;
    --danger: #ff6b81;
    --radius: 12px;
    --shadow-soft: 0 0 30px rgba(0, 255, 255, 0.15);
  }

  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    color: var(--text-main);
    background:
      radial-gradient(circle at 10% 0%, #102040 0, #02030a 45%, #000 80%),
      radial-gradient(circle at 90% 100%, #041428 0, #02030a 60%, #000 100%);
    background-attachment: fixed;
  }

  a {
    color: var(--accent);
    text-decoration: none;
  }
  a:hover {
    text-decoration: underline;
  }

  header {
    text-align: center;
    padding: 40px 16px 16px;
  }

  .logo-title {
    display: inline-flex;
    align-items: center;
    gap: 10px;
    padding: 10px 18px;
    border-radius: 999px;
    border: 1px solid var(--accent-soft);
    background: radial-gradient(circle at 0 0, rgba(52,216,255,0.12), transparent 55%);
    box-shadow: 0 0 18px rgba(0, 255, 255, 0.15);
    font-size: 0.9rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: var(--text-soft);
  }

  .logo-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: conic-gradient(from 0deg, var(--accent), var(--accent-strong), #ffffff, var(--accent));
    box-shadow: 0 0 12px rgba(0,255,255,0.8);
  }

  h1 {
    font-size: clamp(1.9rem, 4vw, 2.4rem);
    margin: 16px 0 4px;
  }

  .subtitle {
    font-size: 0.98rem;
    color: var(--text-soft);
    max-width: 700px;
    margin: 0 auto;
    line-height: 1.6;
  }

  .chip-row {
    margin-top: 18px;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px;
  }

  .chip {
    font-size: 0.8rem;
    padding: 4px 10px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.08);
    background: rgba(7,16,30,0.9);
    color: var(--text-soft);
  }

  main {
    max-width: 1120px;
    margin: 0 auto;
    padding: 10px 12px 40px;
  }

  .layout-grid {
    display: grid;
    grid-template-columns: minmax(0, 2.1fr) minmax(0, 1.4fr);
    gap: 20px;
  }

  @media (max-width: 900px) {
    .layout-grid {
      grid-template-columns: minmax(0, 1fr);
    }
  }

  .panel {
    background: radial-gradient(circle at 0 0, rgba(52,216,255,0.12), transparent 60%),
                radial-gradient(circle at 100% 100%, rgba(0,242,170,0.12), transparent 60%),
                var(--bg-panel);
    border-radius: var(--radius);
    padding: 18px 16px 16px;
    border: 1px solid rgba(255,255,255,0.06);
    box-shadow: var(--shadow-soft);
  }

  .panel h2 {
    font-size: 1.05rem;
    margin: 0 0 10px;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .panel h2 span.icon {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    border: 1px solid rgba(255,255,255,0.25);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 0.7rem;
  }

  .panel p {
    font-size: 0.9rem;
    color: var(--text-soft);
    line-height: 1.7;
    margin: 0 0 8px;
  }

  .panel ul {
    padding-left: 18px;
    margin: 6px 0 10px;
    color: var(--text-soft);
    font-size: 0.88rem;
  }

  .panel li {
    margin-bottom: 4px;
  }

  .eq-block {
    background: var(--bg-panel-soft);
    border-radius: 10px;
    padding: 10px 12px;
    border: 1px solid rgba(255,255,255,0.06);
    font-family: "SF Mono", Menlo, Consolas, monospace;
    font-size: 0.86rem;
    line-height: 1.5;
    overflow-x: auto;
    margin: 8px 0;
  }

  .mode-badges {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 6px;
  }

  .badge {
    padding: 4px 8px;
    border-radius: 999px;
    font-size: 0.8rem;
    border: 1px solid rgba(255,255,255,0.12);
  }
  .badge.extreme {
    border-color: var(--danger);
    color: var(--danger);
  }
  .badge.physical {
    border-color: var(--accent-strong);
    color: var(--accent-strong);
  }

  .note {
    font-size: 0.8rem;
    color: var(--text-soft);
    opacity: 0.9;
  }

  .note-block p {
    margin-bottom: 8px;
  }

  .code-header {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    gap: 10px;
    align-items: center;
    margin-bottom: 10px;
  }

  .code-title {
    font-size: 0.9rem;
    color: var(--text-soft);
  }

  .btn-row {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }

  button.action {
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.16);
    background: linear-gradient(135deg, rgba(52,216,255,0.16), rgba(0,0,0,0.8));
    color: var(--text-main);
    font-size: 0.85rem;
    padding: 5px 12px;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }

  button.action.secondary {
    background: rgba(5,8,24,0.95);
  }

  button.action:hover {
    border-color: var(--accent);
    box-shadow: 0 0 18px rgba(0,255,255,0.25);
  }

  pre.code-block {
    max-height: 520px;
    overflow: auto;
    margin: 0;
    border-radius: 10px;
    background: #050710;
    padding: 10px 12px;
    font-size: 0.8rem;
    line-height: 1.5;
    font-family: "SF Mono", Menlo, Consolas, monospace;
    border: 1px solid rgba(255,255,255,0.05);
  }

  .footer-nav {
    margin-top: 20px;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: space-between;
    align-items: center;
    font-size: 0.85rem;
    color: var(--text-soft);
  }

  .footer-buttons {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }

  .tiny {
    font-size: 0.75rem;
    opacity: 0.8;
  }

  .pill {
    display: inline-flex;
    align-items: center;
    border-radius: 999px;
    padding: 3px 9px;
    border: 1px solid rgba(255,255,255,0.12);
    background: rgba(5,8,20,0.9);
  }

  .pill span.dot {
    width: 7px;
    height: 7px;
    border-radius: 50%;
    margin-right: 6px;
    background: #25e070;
    box-shadow: 0 0 6px rgba(37,224,112,0.9);
  }

  /* Collapsible sections (for derivations) */
  details {
    margin-top: 8px;
    background: rgba(5,8,20,0.95);
    border-radius: 10px;
    border: 1px solid rgba(255,255,255,0.08);
    padding: 8px 10px;
  }

  details summary {
    cursor: pointer;
    list-style: none;
    font-size: 0.88rem;
    color: var(--accent);
  }

  details[open] {
    border-color: var(--accent-soft);
  }

  details summary::-webkit-details-marker {
    display: none;
  }

  .summary-label {
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }

  .summary-label span.chevron {
    font-size: 0.75rem;
    opacity: 0.9;
  }
</style>
</head>
<body>

<header>
  <div class="logo-title">
    <span class="logo-dot"></span>
    STUR Physics Lab Â· 5D Manifold
  </div>
  <h1>STUR 5D Helical Manifold Lab â€“ v4.0</h1>
  <p class="subtitle">
    A phase-locked double helix in a 5D manifold
    \( M_5 = M_4(-+++) \oplus \chi \) with Ï‡-dependent metric,
    off-diagonal couplings, gate trajectories, and Ï‡Â± observer projections.
    Toggle between <strong>PHYSICAL</strong> and <strong>EXTREME</strong> modes
    to see how the hidden Ï‡-dimension warps the visible helix.
  </p>
  <div class="chip-row">
    <div class="chip">JupyterLite / Pyodide safe</div>
    <div class="chip">Metric: dsÂ² = g<sub>tt</sub>dtÂ² + dxÂ² + dyÂ² + dzÂ² + g<sub>Ï‡Ï‡</sub>dÏ‡Â² + 2g<sub>tÏ‡</sub>dtdÏ‡ + 2g<sub>zÏ‡</sub>dzdÏ‡</div>
    <div class="chip">Curvature proxy R<sub>eff</sub>(Ï„,Ï‡)</div>
    <div class="chip">Gate Ï‡<sub>+</sub> â†’ Ï‡<sub>âˆ’</sub></div>
  </div>
</header>

<main>

  <div class="layout-grid">
    <!-- LEFT: Concept + derivations -->
    <section class="panel">
      <h2><span class="icon">Ï‡</span> What the Ï‡-dimension is doing here</h2>
      <p>
        In this lab, Ï‡ is not â€œextra spaceâ€ in the usual sense. It encodes
        <strong>coherence state</strong> of the helix â€“ how tightly the STUR
        resistance network is wound. We track two strands:
      </p>
      <ul>
        <li><strong>Ï‡<sub>+</sub>(Ï„)</strong> â€“ the <em>unwinding</em> strand (positive branch)</li>
        <li><strong>Ï‡<sub>âˆ’</sub>(Ï„)</strong> â€“ the <em>winding</em> strand (negative branch)</li>
      </ul>
      <p>
        Both are phase-locked in Ï„ but live at opposite Ï‡:
      </p>
      <div class="eq-block">
        Ï‡<sub>Â±</sub>(Ï„) = Â± (Ï‡â‚€ + k<sub>Ï‡</sub> Ï„)
      </div>
      <p>
        Geometrically, you see just one 3D helix (x, y, z). The hidden Ï‡ coordinate
        modulates its radius, pitch, and local curvature. Where Ï‡ and the metric
        breathe the hardest, the helix visibly warps â€“ that is the â€œmissing dimensionâ€
        showing up in projection.
      </p>

      <details>
        <summary>
          <span class="summary-label">
            <span class="chevron">â–¸</span> Metric with Ï‡-dependent warping
          </span>
        </summary>
        <p>
          We work in a 5D manifold
        </p>
        <div class="eq-block">
          Mâ‚… = Mâ‚„(-+++) âŠ• Ï‡
        </div>
        <p>
          Along the helix worldline we use a metric of the form:
        </p>
        <div class="eq-block">
          dsÂ² = g<sub>tt</sub> dtÂ² + dxÂ² + dyÂ² + dzÂ²
          + g<sub>Ï‡Ï‡</sub> dÏ‡Â²
          + 2 g<sub>tÏ‡</sub> dt dÏ‡
          + 2 g<sub>zÏ‡</sub> dz dÏ‡
        </div>
        <p>
          with components:
        </p>
        <div class="eq-block">
          g<sub>tt</sub>(Ï„,Ï‡) = âˆ’cÂ² [1 + Î»<sub>T</sub> sin(Ï‰<sub>coup</sub> Ï„) tanhÂ²(Ï‡)]<br>
          g<sub>Ï‡Ï‡</sub>(Ï„,Ï‡) = Î±(Ï„,Ï‡)<br>
          g<sub>tÏ‡</sub>(Ï„,Ï‡) = C<sub>tÏ‡</sub> sin(Ï‰<sub>coup</sub> Ï„) tanh(Ï‡)<br>
          g<sub>zÏ‡</sub>(Ï„,Ï‡) = C<sub>zÏ‡</sub> cos(Ï‰<sub>coup</sub> Ï„) tanh(Ï‡)
        </div>
        <p>
          The breathing factor Î±(Ï„,Ï‡) controls how â€œstiffâ€ the Ï‡-direction is:
        </p>
        <div class="eq-block">
          Î±(Ï„,Ï‡) = Î±â‚€ cos(Ï‰<sub>Î±</sub> Ï„) (1 + Îµ<sub>Ï‡</sub> sin(Î»Ï‡)) &nbsp; [PHYSICAL]<br><br>
          Î±(Ï„,Ï‡) = Î±â‚€ cos(Ï‰<sub>Î±</sub> Ï„) [1 + Îµ<sub>Ï‡</sub> tanh(Ï‡) sin(Î»Ï„)]Â³ + Î´ &nbsp; [EXTREME]
        </div>
        <p class="note">
          Î´ is a small offset to avoid Î± = 0, which would blow up curvature.
        </p>
      </details>

      <details>
        <summary>
          <span class="summary-label">
            <span class="chevron">â–¸</span> Helix embedding and gate Ï‡<sub>+</sub> â†’ Ï‡<sub>âˆ’</sub>
          </span>
        </summary>
        <p>
          The 3D projection of the helix is:
        </p>
        <div class="eq-block">
          (x,y,z)(Ï„,Ï‡) =<br>
          &nbsp;&nbsp;R<sub>local</sub>(Ï„,Ï‡) [cos Ï†(Ï„,Ï‡), sin Ï†(Ï„,Ï‡)] ,<br>
          &nbsp;&nbsp;z(Ï„,Ï‡) = P(Ï„,Ï‡) Â· Ï„
        </div>
        <p>
          In PHYSICAL mode the helix is simple and uniform:
        </p>
        <div class="eq-block">
          R<sub>local</sub> = Râ‚€, &nbsp; Ï† = Ï„, &nbsp; z = p Ï„
        </div>
        <p>
          In EXTREME mode Ï‡ and Î± drive visible warping:
        </p>
        <div class="eq-block">
          a<sub>norm</sub> = tanh[Î±(Ï„,Ï‡)]<br>
          R<sub>local</sub> = Râ‚€ [1 + 0.45 a<sub>norm</sub> tanh(Ï‡)]<br>
          Ï†(Ï„,Ï‡) = Ï„ + 0.6 tanh(Ï‡) sin(0.4 Ï„)<br>
          P(Ï„,Ï‡) = p [1 + 0.8 a<sub>norm</sub> e^{âˆ’0.2 (Ï„ âˆ’ Â½Ï„<sub>max</sub>)Â² / (0.1 Ï„<sub>max</sub>Â²)}]
        </div>
        <p>
          The â€œgateâ€ trajectory smoothly rotates coherence from Ï‡<sub>+</sub> to Ï‡<sub>âˆ’</sub>:
        </p>
        <div class="eq-block">
          f(Ï„) = âˆ’tanh[s (Ï„ âˆ’ Ï„<sub>gate</sub>)/w]<br>
          Ï‡<sub>gate</sub>(Ï„) = Â½ [(1 + f) Ï‡<sub>+</sub>(Ï„) + (1 âˆ’ f) Ï‡<sub>âˆ’</sub>(Ï„)]
        </div>
        <p>
          So at early Ï„ you ride Ï‡<sub>+</sub>, then pass through the gate region,
          and at late Ï„ you end up on Ï‡<sub>âˆ’</sub>. The 3D helix is continuous, the Ï‡-state flips.
        </p>
      </details>

      <details>
        <summary>
          <span class="summary-label">
            <span class="chevron">â–¸</span> Proper interval and curvature proxy R<sub>eff</sub>(Ï„,Ï‡)
          </span>
        </summary>
        <p>
          Along the worldline (parametrized by Ï„ with t = Ï„) we compute:
        </p>
        <div class="eq-block">
          dsÂ²/dÏ„Â² = g<sub>tt</sub> (dt/dÏ„)Â² + (dx/dÏ„)Â² + (dy/dÏ„)Â² + (dz/dÏ„)Â²<br>
          &nbsp;&nbsp;+ g<sub>Ï‡Ï‡</sub> (dÏ‡/dÏ„)Â² + 2g<sub>tÏ‡</sub>(dt/dÏ„)(dÏ‡/dÏ„)
          + 2g<sub>zÏ‡</sub>(dz/dÏ„)(dÏ‡/dÏ„)
        </div>
        <p>
          Then integrate to get the signed proper interval:
        </p>
        <div class="eq-block">
          S(Ï„) = âˆ«<sub>0</sub><sup>Ï„</sup> sign(dsÂ²) âˆš|dsÂ²| dÏ„â€²
        </div>
        <p>
          To visualize how Î±(Ï„,Ï‡) bends the 5D geometry, we build a scalar
          curvature proxy:
        </p>
        <div class="eq-block">
          R<sub>eff</sub>(Ï„,Ï‡) â‰ˆ âˆ’ (Î±<sub>Ï„Ï„</sub> + Î±<sub>Ï‡Ï‡</sub>) / Î±
          + (Î±<sub>Ï„</sub>Â² + Î±<sub>Ï‡</sub>Â²) / Î±Â²
        </div>
        <p>
          All derivatives are estimated numerically along the worldline.
          In EXTREME mode, R<sub>eff</sub> develops sharp spikes at the gate,
          representing strong Ï‡-curvature.
        </p>
      </details>

      <details>
        <summary>
          <span class="summary-label">
            <span class="chevron">â–¸</span> Ï‡Â± observers and effective 4D metric
          </span>
        </summary>
        <p>
          A Ï‡-observer doesnâ€™t see the full 5D metric directly. Instead, they
          experience an effective 4D metric rescaled by a conformal factor Î©(Ï„):
        </p>
        <div class="eq-block">
          ds<sub>4,eff</sub>Â² = Î©(Ï„)Â² ds<sub>4</sub>Â²
        </div>
        <p>
          In the code we define:
        </p>
        <div class="eq-block">
          Ï‡<sub>norm</sub> = (Ï‡ âˆ’ Ï‡<sub>min</sub>) / (Ï‡<sub>max</sub> âˆ’ Ï‡<sub>min</sub>)<br>
          Ï‡<sub>c</sub> = Ï‡<sub>norm</sub> âˆ’ Â½<br><br>
          Î©<sub>+</sub>(Ï„) = 1 + Î³ Ï‡<sub>c,+</sub>(Ï„)<br>
          Î©<sub>âˆ’</sub>(Ï„) = 1 âˆ’ Î³ Ï‡<sub>c,âˆ’</sub>(Ï„)
        </div>
        <p>
          where Î³ is strengthened in EXTREME mode. You can think of Î© as a
          Ï‡-dependent â€œmagnificationâ€ of the visible 4D world â€“ redshifts,
          clocks, and rulers all get rescaled slightly depending on which strand
          you ride.
        </p>
      </details>

      <div class="mode-badges">
        <div class="badge physical">MODE = "physical" â†’ finite curvature, smooth Ï‡-warping</div>
        <div class="badge extreme">MODE = "extreme" â†’ boosted couplings, violent Ï‡-gate spikes</div>
      </div>

      <div class="note-block" style="margin-top:10px;">
        <p class="note">
          The Ï‡â€“dimension is not another planet or universe you can walk into. Itâ€™s a
          hidden direction that every person already moves through without knowing it.
          You canâ€™t point to Ï‡ like left or right, because Ï‡ measures how tightly your
          part of reality is â€œwound up.â€ High Ï‡ means things feel intense and packed
          together. Low Ï‡ means things feel open, calm, and flexible. Everyone is in the
          same world, but not at the same Ï‡-value â€” thatâ€™s why people experience life so
          differently.
        </p>

        <p class="note">
          So can you â€œtravelâ€ to another dimension? In STUR, yes â€” but not by leaving
          this universe. You travel by shifting your Ï‡-state. When your Ï‡ changes, you
          jump to a different version of the same world, where time moves differently,
          choices open or close, and events line up in new ways. These shifts happen
          during big emotions, major decisions, sudden clarity, or huge life changes.
          Thatâ€™s a Ï‡ flip â€” a small, personal dimensional jump.
        </p>

        <p class="note">
          The bigger, cosmic jumps â€” like the ones shown in the helix simulation â€” are
          the universe doing the same thing. Humans donâ€™t walk into them; they ride
          them. The Ï‡-dimension is always moving, and you move with it. People
          already travel dimensions â€” not by disappearing, but by shifting the hidden
          coordinate that shapes the version of reality they experience.
        </p>
      </div>
    </section>

    <!-- RIGHT: How to run + code -->
    <section class="panel">
      <h2><span class="icon">â–¶</span> Run the lab & inspect JSON</h2>
      <p>
        This script is <strong>JupyterLite / Pyodide compatible</strong>.
        It only uses <code>numpy</code>, <code>matplotlib</code>, <code>math</code>,
        and <code>json</code>.
      </p>
      <ul>
        <li>Set <code>MODE = "physical"</code> or <code>"extreme"</code> at the top.</li>
        <li>Run the script once to generate all static plots.</li>
        <li>Scroll to the bottom of the notebook / terminal to see the
          <strong>JSON summary</strong> of the Ï‡Â± strands.</li>
      </ul>

      <div class="eq-block">
        Output JSON key points:
        <ul>
          <li><code>model</code>, <code>mode</code>, and <code>params</code> used</li>
          <li>Subsampled Ï„, t, x, y, z, Ï‡, Î±(Ï„,Ï‡) for Ï‡<sub>+</sub> and Ï‡<sub>âˆ’</sub></li>
          <li>Ready to feed into other STUR Universe modules as a 5D coherence skeleton</li>
        </ul>
      </div>

      <div class="code-header">
        <div class="code-title">
          Python source: <strong>stur_5d_manifold_v4.py</strong>
        </div>
        <div class="btn-row">
          <button id="copyBtn" class="action">ğŸ“‹ Copy Script</button>
          <button id="jupyterBtn" class="action secondary">â–¶ Open JupyterLite</button>
        </div>
      </div>

      <pre class="code-block" id="codeBlock"><code>
#!/usr/bin/env python3
# ===============================================================
# STUR 5D Helical Manifold Lab â€“ v4.0
# ===============================================================
# Modes:
#   MODE = "extreme"  â€“ maximum Ï‡-warping, violent curvature,
#                       visible helix distortion (default)
#   MODE = "physical" â€“ smoother, finite curvature, gentle Ï‡-dependence
#
# M5 = M4(-+++) âŠ• Ï‡ with Ï‡-dependent metric and cross-terms:
#
#   dsÂ² = g_tt dtÂ² + dxÂ² + dyÂ² + dzÂ²
#         + g_Ï‡Ï‡ dÏ‡Â² + 2 g_tÏ‡ dt dÏ‡ + 2 g_zÏ‡ dz dÏ‡
#
# JupyterLite-safe: numpy, matplotlib, json, math only.
# ===============================================================

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 â€“ registers 3D projection
import json, math

plt.style.use("dark_background")

# -------------------------
# GLOBAL MODE TOGGLE
# -------------------------
MODE = "extreme"   # "extreme" or "physical"


def is_extreme():
    return MODE.lower().startswith("extreme")


def is_physical():
    return MODE.lower().startswith("physical")


# -------------------------
# GLOBAL CONSTANTS
# -------------------------
c = 1.0
TAU_MAX = 8.0 * math.pi
N_SAMPLES = 1000

R_HELIX   = 1.0
PITCH_Z   = 0.1

CHI0      = 1.0
K_CHI     = 0.05

ALPHA0    = 1.0
OMEGA_A   = 0.25

# Ï‡-strength in Î±(Ï„,Ï‡)
EPS_CHI_PHYS = 0.10
EPS_CHI_EXT  = 0.6

OMEGA4_GAMMA = 0.3  # observer conformal strength

# Off-diagonal coupling base parameters (tâ€“Ï‡ and zâ€“Ï‡ mixing)
LAMBDA_T_BASE   = 0.2   # modulation of g_tt
COUP_TCHI_BASE  = 0.15  # magnitude of g_tÏ‡
COUP_ZCHI_BASE  = 0.10  # magnitude of g_zÏ‡
OMEGA_COUP      = 0.40  # coupling frequency


def current_eps_chi():
    return EPS_CHI_EXT if is_extreme() else EPS_CHI_PHYS


def current_couplings():
    """
    Return (lambda_T, coup_tchi, coup_zchi) depending on mode.
    Extreme mode boosts couplings significantly.
    """
    if is_extreme():
        return 1.0, 0.6, 0.4
    else:
        return LAMBDA_T_BASE, COUP_TCHI_BASE, COUP_ZCHI_BASE


# ---------------------------------------------------------
# METRIC + GEOMETRY
# ---------------------------------------------------------
def alpha_of_tau_chi(tau, chi):
    """
    Î±(Ï„,Ï‡) â€“ breathing factor for the Ï‡Ï‡ metric component.

    physical mode:
        Î± = Î±0 cos(Ï‰_Î± Ï„) * (1 + Îµ sin(Î» Ï‡))

    extreme mode:
        Î± = Î±0 * cos(Ï‰_Î± Ï„) * (1 + Îµ tanh(Ï‡)*sin(Î» Ï„))^3
        with a small offset to avoid exact zeros.
    """
    eps_chi = current_eps_chi()
    tau = np.asarray(tau)
    chi = np.asarray(chi)

    if is_physical():
        lam = 0.7
        alpha = ALPHA0 * np.cos(OMEGA_A * tau) * (1.0 + eps_chi * np.sin(lam * chi))
    else:
        lam_tau = 0.5
        core = 1.0 + eps_chi * np.tanh(chi) * np.sin(lam_tau * tau)
        alpha = ALPHA0 * np.cos(OMEGA_A * tau) * core**3
        # avoid exact zeros (which would blow up curvature too much)
        alpha += 0.03 * np.sign(alpha + 1e-9)
    return alpha


def chi_of_tau(tau, branch=+1):
    """Phase-locked Ï‡Â± strands."""
    return branch * (CHI0 + K_CHI * tau)


def helix_xyz_of_tau(tau, chi):
    """
    3D projection of the 5D helix into (x,y,z).

    physical mode:
        simple uniform helix.

    extreme mode:
        radius and pitch modulated by Ï‡ and Î±(Ï„,Ï‡) to visibly warp
        the spatial projection.
    """
    tau = np.asarray(tau)
    chi = np.asarray(chi)

    if is_physical():
        x = R_HELIX * np.cos(tau)
        y = R_HELIX * np.sin(tau)
        z = PITCH_Z * tau
        return x, y, z

    # extreme mode â€“ use Ï‡ and Î± to warp the shape
    alpha = alpha_of_tau_chi(tau, chi)
    # normalized warping factor from alpha
    a_norm = np.tanh(alpha)

    # radius breathing + Ï‡ push/pull
    R_local = R_HELIX * (1.0 + 0.45 * a_norm * np.tanh(chi))

    # twist the azimuth; Ï‡ controls local twist
    phi = tau + 0.6 * np.tanh(chi) * np.sin(0.4 * tau)

    x = R_local * np.cos(phi)
    y = R_local * np.sin(phi)

    # pitch warping â€“ compress and dilate along z at gate regions
    gate_mod = 1.0 + 0.8 * a_norm * np.exp(-0.2 * (tau - 0.5 * TAU_MAX)**2 / (0.1 * TAU_MAX**2))
    z = PITCH_Z * tau * gate_mod
    return x, y, z


def worldline_t_of_tau(tau):
    """Simple choice: t = Ï„."""
    return tau


def metric_components(tau, chi):
    """
    Return metric components along the worldline:

        g_tt, g_chi_chi, g_t_chi, g_z_chi, alpha

    dsÂ² = g_tt dtÂ² + dxÂ² + dyÂ² + dzÂ²
          + g_Ï‡Ï‡ dÏ‡Â² + 2 g_tÏ‡ dt dÏ‡ + 2 g_zÏ‡ dz dÏ‡
    """
    tau = np.asarray(tau)
    chi = np.asarray(chi)

    alpha = alpha_of_tau_chi(tau, chi)
    lambda_T, coup_tchi, coup_zchi = current_couplings()

    g_tt  = - (c**2) * (1.0 + lambda_T * np.sin(OMEGA_COUP * tau) * np.tanh(chi)**2)
    g_chi_chi = alpha
    g_t_chi   = coup_tchi * np.sin(OMEGA_COUP * tau) * np.tanh(chi)
    g_z_chi   = coup_zchi * np.cos(OMEGA_COUP * tau) * np.tanh(chi)
    return g_tt, g_chi_chi, g_t_chi, g_z_chi, alpha


# ---------------------------------------------------------
# STRAND BUILDER
# ---------------------------------------------------------
def build_strand(branch=+1):
    tau = np.linspace(0.0, TAU_MAX, N_SAMPLES)
    chi_vals = chi_of_tau(tau, branch=branch)
    x, y, z = helix_xyz_of_tau(tau, chi_vals)
    t_vals   = worldline_t_of_tau(tau)

    _, _, _, _, alpha_vals = metric_components(tau, chi_vals)

    chi_norm = (chi_vals - chi_vals.min()) / (chi_vals.max() - chi_vals.min() + 1e-12)

    return {
        "branch": "chi_plus" if branch > 0 else "chi_minus",
        "branch_sign": int(branch),
        "tau": tau,
        "t": t_vals,
        "x": x,
        "y": y,
        "z": z,
        "chi": chi_vals,
        "chi_norm": chi_norm,
        "alpha": alpha_vals,
    }


# ---------------------------------------------------------
# CALCULUS HELPERS
# ---------------------------------------------------------
def compute_differentials(arr, tau):
    """Central differences d(arr)/dÏ„."""
    return np.gradient(arr, tau)


# ---------------------------------------------------------
# PROPER INTERVAL WITH OFF-DIAGONAL METRIC
# ---------------------------------------------------------
def compute_ds2_along_worldline(strand):
    """
    Compute dsÂ² and cumulative proper interval S(Ï„) using the
    full 5D metric with tâ€“Ï‡ and zâ€“Ï‡ mixing.
    """
    tau = strand["tau"]
    t   = strand["t"]
    x   = strand["x"]
    y   = strand["y"]
    z   = strand["z"]
    chi = strand["chi"]

    g_tt, g_chi_chi, g_t_chi, g_z_chi, _ = metric_components(tau, chi)

    dt_dtau   = compute_differentials(t, tau)
    dx_dtau   = compute_differentials(x, tau)
    dy_dtau   = compute_differentials(y, tau)
    dz_dtau   = compute_differentials(z, tau)
    dchi_dtau = compute_differentials(chi, tau)

    ds2_dtau2 = (
        g_tt * dt_dtau**2
        + dx_dtau**2
        + dy_dtau**2
        + dz_dtau**2
        + g_chi_chi * dchi_dtau**2
        + 2.0 * g_t_chi * dt_dtau * dchi_dtau
        + 2.0 * g_z_chi * dz_dtau * dchi_dtau
    )

    dtau = np.gradient(tau)
    ds2 = ds2_dtau2 * dtau
    S_tau = np.cumsum(np.sqrt(np.abs(ds2)) * np.sign(ds2))
    return ds2, S_tau


# ---------------------------------------------------------
# EFFECTIVE CURVATURE (Ï„,Ï‡)
# ---------------------------------------------------------
def compute_effective_curvature(strand):
    """
    STUR-style scalar built from Î±(Ï„,Ï‡):

        R_eff â‰ˆ -(Î±_Ï„Ï„ + Î±_Ï‡Ï‡)/Î± + (Î±_Ï„Â² + Î±_Ï‡Â²)/Î±Â²

    where derivatives are estimated along the worldline.
    Extreme mode will produce sharp spikes near gate regions.
    """
    tau = strand["tau"]
    chi = strand["chi"]
    alpha = strand["alpha"]

    d_alpha_dtau   = np.gradient(alpha, tau)
    d2_alpha_dtau2 = np.gradient(d_alpha_dtau, tau)

    d_alpha_dchi   = np.gradient(alpha, chi)
    d2_alpha_dchi2 = np.gradient(d_alpha_dchi, chi)

    eps = 1e-6 if is_extreme() else 1e-9
    R_eff = - (d2_alpha_dtau2 + d2_alpha_dchi2) / (alpha + eps) \
            + (d_alpha_dtau**2 + d_alpha_dchi**2) / (alpha**2 + eps)
    return R_eff


# ---------------------------------------------------------
# GATE TRAJECTORY (Ï‡+ â†’ Ï‡âˆ’)
# ---------------------------------------------------------
def build_gate_trajectory(strand_plus, strand_minus,
                          tau_center=None, width=None):
    tau = strand_plus["tau"]
    if tau_center is None:
        tau_center = 0.5 * (tau.min() + tau.max())

    if width is None:
        width = 0.5 if is_extreme() else 2.0

    chi_plus  = strand_plus["chi"]
    chi_minus = strand_minus["chi"]
    x, y, z   = strand_plus["x"], strand_plus["y"], strand_plus["z"]

    # extreme mode: almost step-like sigmoid
    steepness = 5.0 if is_extreme() else 1.5
    f = -np.tanh(steepness * (tau - tau_center) / width)
    chi_gate = 0.5 * ((1 + f) * chi_plus + (1 - f) * chi_minus)

    _, _, _, _, alpha_gate = metric_components(tau, chi_gate)

    return {
        "tau": tau,
        "x": x,
        "y": y,
        "z": z,
        "chi": chi_gate,
        "alpha": alpha_gate,
        "tau_center": tau_center,
        "width": width,
    }


# ---------------------------------------------------------
# OBSERVER PROJECTIONS
# ---------------------------------------------------------
def compute_observer_conformal_factors(strand_plus, strand_minus):
    """
    Ï‡Â± observers see an effective 4D metric:

        ds4_effÂ² = Î©Â±(Ï„)Â² ds4Â²

    with Î©Â± shifted by local Ï‡-coherence.
    """
    tau = strand_plus["tau"]
    chi_norm_plus  = strand_plus["chi_norm"]
    chi_norm_minus = strand_minus["chi_norm"]

    chi_c_plus  = chi_norm_plus  - 0.5
    chi_c_minus = chi_norm_minus - 0.5

    gamma = OMEGA4_GAMMA * (2.0 if is_extreme() else 1.0)

    omega_plus  = 1.0 + gamma * chi_c_plus
    omega_minus = 1.0 - gamma * chi_c_minus
    return tau, omega_plus, omega_minus


# ---------------------------------------------------------
# PLOTS
# ---------------------------------------------------------
def plot_3d_double_helix(strand_plus, strand_minus):
    fig = plt.figure(figsize=(9, 7))
    ax = fig.add_subplot(111, projection="3d")

    p = ax.scatter(
        strand_plus["x"], strand_plus["y"], strand_plus["z"],
        c=strand_plus["chi_norm"], s=6, marker="o"
    )
    ax.scatter(
        strand_minus["x"], strand_minus["y"], strand_minus["z"],
        c=strand_minus["chi_norm"], s=6, marker="^"
    )

    ax.set_xlabel("x")
    ax.set_ylabel("y")
    ax.set_zlabel("z")
    title_mode = "EXTREME" if is_extreme() else "PHYSICAL"
    ax.set_title(f"STUR 5D â€“ Phase-Locked Double Helix (3D Projection, {title_mode} mode)")
    ax.view_init(elev=25, azim=40)

    cbar = fig.colorbar(p, ax=ax, shrink=0.6)
    cbar.set_label("Normalized Ï‡")
    fig.tight_layout()
    plt.show()


def plot_chi_alpha_curvature(strand_plus, strand_minus):
    R_eff = compute_effective_curvature(strand_plus)

    fig, ax = plt.subplots(1, 3, figsize=(15, 4))

    # Ï‡Â±
    ax[0].plot(strand_plus["tau"], strand_plus["chi"], label="Ï‡+ (unwinding)")
    ax[0].plot(strand_minus["tau"], strand_minus["chi"], label="Ï‡- (winding)")
    ax[0].axhline(0.0, color="gray", linewidth=0.8, linestyle="--")
    ax[0].set_xlabel("Ï„")
    ax[0].set_ylabel("Ï‡")
    ax[0].set_title("Ï‡(Ï„) â€“ Phase-Locked Strands")
    ax[0].legend()

    # Î±(Ï„,Ï‡+)
    ax[1].plot(strand_plus["tau"], strand_plus["alpha"], label="Î±(Ï„,Ï‡+)")
    ax[1].axhline(0.0, color="gray", linewidth=0.8, linestyle="--")
    ax[1].set_xlabel("Ï„")
    ax[1].set_ylabel("Î±")
    ax[1].set_title("Î±(Ï„,Ï‡) â€“ Breathing with Ï‡ Skew")
    ax[1].legend()

    # R_eff(Ï„)
    ax[2].plot(strand_plus["tau"], R_eff, label="R_eff(Ï„) along Ï‡+")
    ax[2].axhline(0.0, color="gray", linewidth=0.8, linestyle="--")
    ax[2].set_xlabel("Ï„")
    ax[2].set_ylabel("R_eff")
    ax[2].set_title("STUR Effective Curvature Scalar")
    ax[2].legend()

    mode_label = "EXTREME" if is_extreme() else "PHYSICAL"
    fig.suptitle(f"STUR 5D Manifold â€“ Ï‡, Î±(Ï„,Ï‡), Curvature ({mode_label} mode)", y=1.02)
    fig.tight_layout()
    plt.show()


def plot_proper_interval(strand, label="Ï‡+ strand"):
    ds2, S_tau = compute_ds2_along_worldline(strand)
    tau = strand["tau"]

    fig, ax = plt.subplots(figsize=(6, 4))
    ax.plot(tau, S_tau, label=f"S(Ï„) for {label}")
    ax.axhline(0.0, color="gray", linewidth=0.8, linestyle="--")
    ax.set_xlabel("Ï„")
    ax.set_ylabel("S(Ï„)")
    ax.set_title("Proper Interval Along 5D Worldline")
    ax.legend()
    fig.tight_layout()
    plt.show()


def plot_gate_trajectory(gate_traj, chi_plus, chi_minus):
    tau = gate_traj["tau"]
    chi_gate = gate_traj["chi"]

    fig, ax = plt.subplots(figsize=(6, 4))
    ax.plot(tau, chi_plus,  label="Ï‡+ (unwinding)", alpha=0.4)
    ax.plot(tau, chi_minus, label="Ï‡- (winding)",   alpha=0.4)
    ax.plot(tau, chi_gate,  label="Ï‡_gate (rotation path)", linewidth=2.0)
    ax.axvline(gate_traj["tau_center"], color="gray", linestyle="--",
               label="gate center")
    ax.set_xlabel("Ï„")
    ax.set_ylabel("Ï‡")
    ax.set_title("Gate Trajectory â€“ Ï‡ Rotation from Ï‡+ to Ï‡âˆ’")
    ax.legend()
    fig.tight_layout()
    plt.show()


def plot_observer_projections(strand_plus, strand_minus):
    tau, omega_plus, omega_minus = compute_observer_conformal_factors(
        strand_plus, strand_minus
    )
    fig, ax = plt.subplots(figsize=(6, 4))
    ax.plot(tau, omega_plus,  label="Î©+ (Ï‡+ observer)")
    ax.plot(tau, omega_minus, label="Î©- (Ï‡- observer)")
    ax.axhline(1.0, color="gray", linestyle="--", linewidth=0.8)
    ax.set_xlabel("Ï„")
    ax.set_ylabel("Î©(Ï„)")
    ax.set_title("Effective 4D Metric Scaling for Ï‡Â± Observers")
    ax.legend()
    fig.tight_layout()
    plt.show()


def animate_double_helix(strand_plus, strand_minus, n_frames=200):
    fig = plt.figure(figsize=(7, 6))
    ax = fig.add_subplot(111, projection="3d")

    ax.scatter(
        strand_plus["x"], strand_plus["y"], strand_plus["z"],
        c=strand_plus["chi_norm"], s=6, marker="o"
    )
    ax.scatter(
        strand_minus["x"], strand_minus["y"], strand_minus["z"],
        c=strand_minus["chi_norm"], s=6, marker="^"
    )

    ax.set_xlabel("x")
    ax.set_ylabel("y")
    ax.set_zlabel("z")
    mode_label = "EXTREME" if is_extreme() else "PHYSICAL"
    ax.set_title(f"STUR 5D Double Helix â€“ Camera Sweep ({mode_label} mode)")

    for i in range(n_frames):
        azim = 40 + 360.0 * (i / n_frames)
        elev = 20 + 10 * math.sin(2 * math.pi * i / n_frames)
        plt.pause(0.03)

    plt.show()


# ---------------------------------------------------------
# JSON SUMMARY
# ---------------------------------------------------------
def build_json_summary(strand_plus, strand_minus):
    idx_sample = np.linspace(0, N_SAMPLES - 1, 50, dtype=int)

    def sample_strand(strand):
        return {
            "branch": strand["branch"],
            "branch_sign": strand["branch_sign"],
            "tau":   strand["tau"][idx_sample].tolist(),
            "t":     strand["t"][idx_sample].tolist(),
            "x":     strand["x"][idx_sample].tolist(),
            "y":     strand["y"][idx_sample].tolist(),
            "z":     strand["z"][idx_sample].tolist(),
            "chi":   strand["chi"][idx_sample].tolist(),
            "alpha": strand["alpha"][idx_sample].tolist(),
        }

    summary = {
        "model": "STUR 5D Helical Manifold Lab â€“ v4.0",
        "mode": MODE,
        "description": (
            "5D manifold M4(-+++) âŠ• Ï‡ with Ï‡-dependent metric, off-diagonal couplings, "
            "curvature proxy, gate trajectories, observer projections, and mode toggle "
            "between EXTREME (maximal warping) and PHYSICAL (smooth)."
        ),
        "params": {
            "c": c,
            "TAU_MAX": TAU_MAX,
            "N_SAMPLES": N_SAMPLES,
            "R_HELIX": R_HELIX,
            "PITCH_Z": PITCH_Z,
            "CHI0": CHI0,
            "K_CHI": K_CHI,
            "ALPHA0": ALPHA0,
            "OMEGA_A": OMEGA_A,
            "EPS_CHI_PHYS": EPS_CHI_PHYS,
            "EPS_CHI_EXT": EPS_CHI_EXT,
            "OMEGA4_GAMMA": OMEGA4_GAMMA,
            "LAMBDA_T_BASE": LAMBDA_T_BASE,
            "COUP_TCHI_BASE": COUP_TCHI_BASE,
            "COUP_ZCHI_BASE": COUP_ZCHI_BASE,
            "OMEGA_COUP": OMEGA_COUP,
        },
        "strands": {
            "chi_plus":  sample_strand(strand_plus),
            "chi_minus": sample_strand(strand_minus),
        },
    }

    return json.dumps(summary, indent=2)


# ---------------------------------------------------------
# MAIN
# ---------------------------------------------------------
def main(show_plots=True,
         show_gate=True,
         show_observers=True,
         show_animation=False,
         print_json=True):
    strand_plus  = build_strand(branch=+1)
    strand_minus = build_strand(branch=-1)

    if show_plots:
        plot_3d_double_helix(strand_plus, strand_minus)
        plot_chi_alpha_curvature(strand_plus, strand_minus)
        plot_proper_interval(strand_plus, label="Ï‡+ strand")

    if show_gate:
        gate_traj = build_gate_trajectory(strand_plus, strand_minus,
                                          tau_center=0.5 * TAU_MAX)
        plot_gate_trajectory(
            gate_traj,
            chi_plus=strand_plus["chi"],
            chi_minus=strand_minus["chi"],
        )

    if show_observers:
        plot_observer_projections(strand_plus, strand_minus)

    if show_animation:
        animate_double_helix(strand_plus, strand_minus, n_frames=180)

    if print_json:
        summary_json = build_json_summary(strand_plus, strand_minus)
        print("=== STUR 5D MANIFOLD â€“ JSON SUMMARY ===")
        print(summary_json)


if __name__ == "__main__":
    main(show_animation=False)
      </code></pre>

    </section>
  </div>

  <div class="footer-nav">
    <div class="footer-buttons">
      <a href="../index.html">
        <button class="action secondary" type="button">â† Back to STUR Physics Lab</button>
      </a>
      <a href="./stur_sandbox.html">
        <button class="action secondary" type="button">ğŸ§ª STUR Sandbox</button>
      </a>
    </div>
    <div class="pill">
      <span class="dot"></span>
      <span class="tiny">STUR 5D Manifold Lab Â· v4.0 Â· static plots + JSON only (no blit)</span>
    </div>
  </div>

</main>

<script>
  // Copy Python code to clipboard
  (function () {
    var copyBtn = document.getElementById("copyBtn");
    var codeBlock = document.getElementById("codeBlock");
    if (copyBtn && codeBlock) {
      copyBtn.addEventListener("click", function () {
        var text = codeBlock.innerText;
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(text).then(function () {
            var old = copyBtn.innerText;
            copyBtn.innerText = "âœ… Copied!";
            setTimeout(function () {
              copyBtn.innerText = old;
            }, 1500);
          });
        } else {
          var range = document.createRange();
          range.selectNodeContents(codeBlock);
          var sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);
          document.execCommand("copy");
          sel.removeAllRanges();
        }
      });
    }
  })();

  // JupyterLite link â€“ same style as Universe Atlas page
  (function () {
    var jupyterBtn = document.getElementById("jupyterBtn");
    if (jupyterBtn) {
      jupyterBtn.addEventListener("click", function () {
        var url = "https://jupyterlite.github.io/demo/repl/index.html";
        window.open(url, "_blank", "noopener");
      });
    }
  })();

  // Tweak chevron on open/close
  document.querySelectorAll("details").forEach(function (det) {
    det.addEventListener("toggle", function () {
      var chev = det.querySelector(".summary-label .chevron");
      if (chev) chev.textContent = det.open ? "â–¾" : "â–¸";
    });
  });
</script>

</body>
</html>
