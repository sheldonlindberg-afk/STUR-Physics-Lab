<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Explore STUR Physics ‚Äì Sandbox</title>

<style>
  body {
    background:#050814;
    color:#e6edf3;
    font-family:'Courier New', monospace;
    margin:0;
    padding:1.5rem;
  }
  h1 { text-align:center; color:#ffaa00; margin-bottom:0.5rem; }
  h2 { color:#ffcc33; margin-top:1.5rem; }
  .panel {
    background:#0a0f1f;
    padding:1rem;
    border-radius:8px;
    max-width:900px;
    margin:1rem auto;
    box-shadow:0 0 12px #ffaa0044;
  }
  .text { max-width:900px; margin:0 auto; line-height:1.5; }
  label { display:block; margin-top:12px; }
  input[type=range] { width:100%; }
  canvas {
    width:100%;
    height:260px;
    background:#000;
    border-radius:6px;
    margin-top:1rem;
    display:block;
  }
  button {
    background:#ffaa00;
    color:#050814;
    border:none;
    border-radius:6px;
    padding:8px 14px;
    margin:4px;
    cursor:pointer;
    font-family:'Courier New', monospace;
    font-size:0.9rem;
  }
  button:hover { background:#ffcc33; }
  pre { white-space:pre-wrap; color:#00ffcc; font-size:0.9rem; }
  .links { text-align:center; margin-top:1rem; }
  .links a {
    display:inline-block;
    background:#0e1624;
    color:#5ad0ff;
    border:1px solid #5ad0ff;
    padding:8px 14px;
    border-radius:6px;
    text-decoration:none;
    margin:4px;
    font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;
    font-size:0.9rem;
  }
</style>
</head>
<body>

<h1>Explore STUR Physics ‚Äì Sandbox</h1>

<p class="text">
This page is meant to be simple and honest. Every slider and button works.
You can change the shape of a STUR resistance curve and watch a 1D particle
move along it. This is for curious 8th graders and for PhDs who want a quick,
hands-on feel for the STUR geometry.
</p>

<!-- ===================================================== -->
<!-- STUR SANDBOX ‚Äì CONTROLS + CANVAS -->
<!-- ===================================================== -->
<div class="panel">
  <h2>STUR Geometry & Motion</h2>

  <p style="margin-bottom:0.5rem;">
    Base STUR field (no extra scaling):
    <br><br>
    <code>S(r) = tanh(r / L‚ÇÄ) ¬∑ (1 ‚àí e<sup>‚àír / L‚ÇÄ</sup>)</code>
    <br><br>
    In this sandbox we use a generalized form:
    <br><br>
    <code>S<sub>mod</sub>(r) = A ¬∑ [tanh(r/L‚ÇÄ)]<sup>n</sup> ¬∑ (1 ‚àí e<sup>‚àír/L‚ÇÄ</sup>)</code>
    <br><br>
    and optionally blend it with the analytic derivative:
    <br><br>
    <code>S'<sub>base</sub>(r) = dS(r)/dr</code>
  </p>

  <label>L‚ÇÄ (geometry scale): <span id="L0_val">1.0</span></label>
  <input type="range" id="L0" min="0.2" max="3" value="1" step="0.1">

  <label>A (amplitude scale): <span id="A_val">1.0</span></label>
  <input type="range" id="A" min="0.2" max="3" value="1" step="0.1">

  <label>n (tanh exponent): <span id="n_val">1.0</span></label>
  <input type="range" id="n" min="0.5" max="3" value="1" step="0.1">

  <label>R<sub>max</sub> (horizontal range): <span id="Rmax_val">5.0</span></label>
  <input type="range" id="Rmax" min="2" max="10" value="5" step="0.5">

  <label>d (blend S vs. S‚Ä≤, 0‚Üí1): <span id="d_val">0.00</span></label>
  <input type="range" id="blend" min="0" max="1" value="0" step="0.05">

  <div style="margin-top:0.75rem;">
    <button id="toggleAnim">‚ñ∂ Start Particle</button>
    <button id="resetBtn">‚ü≤ Reset</button>
    <button id="downloadBtn">‚¨á Download Curve Data</button>
  </div>

  <canvas id="plot" width="800" height="260"></canvas>
</div>

<div class="panel">
  <h2>Live Output</h2>
  <pre id="output"></pre>
</div>

<!-- ===================================================== -->
<!-- EDUCATIONAL SECTION ‚Äì SHORT BLOCKS -->
<!-- ===================================================== -->

<div class="panel">
  <h2>How Iteration in Science Works</h2>
  <p class="text">
Science in real life is not a single ‚ÄúEureka!‚Äù. It looks like this:
<br>
<b>try ‚Üí run ‚Üí see what breaks ‚Üí fix one thing ‚Üí try again.</b>
<br><br>
Einstein, Maxwell, Feynman, and everyone else did this. You are allowed to
do it too. This sandbox is for trying, breaking, fixing, and trying again.
  </p>
</div>

<div class="panel">
  <h2>How to Use Python Runners Like Jupyter</h2>
  <p class="text">
A Python runner (Jupyter, JupyterLite, Colab) is a live math notebook:
<br><br>
‚Ä¢ You paste code.<br>
‚Ä¢ You press ‚ÄúRun‚Äù.<br>
‚Ä¢ You see numbers and plots appear.<br><br>
The STUR Lab Python simulations are written so that anyone with a browser can
run them‚Äîno installation, no environment setup. You can take the JSON you
download from this page and load it into Python to make your own plots.
  </p>
</div>

<div class="panel">
  <h2>Using AI to Check Your Work</h2>
  <p class="text">
You can treat AI models like extra reviewers:
<br><br>
‚Ä¢ Ask one AI ‚ÄúWhat is unclear or wrong in this derivation?‚Äù<br>
‚Ä¢ Ask another ‚ÄúIs this logic consistent?‚Äù<br>
‚Ä¢ Compare their feedback and refine your idea.<br><br>
This doesn‚Äôt replace your thinking‚Äîit multiplies your iteration speed and
makes it less scary to be wrong in public.
  </p>
</div>

<div class="panel">
  <h2>Science, Scrutiny, and Openness</h2>
  <p class="text">
Science evolves through scrutiny: people question, test, and refine ideas.
But formal scrutiny (journals, committees, funding) can become a gate that
keeps out new voices and risky ideas.
<br><br>
Pages like this one are about putting some of that power back in your hands:
you can explore geometry, forces, and potential theories of everything on
your own screen, without waiting for permission.
  </p>
</div>

<div class="panel">
  <h2>How to Use This Sandbox</h2>
  <p class="text">
<b>For beginners:</b><br>
‚Ä¢ Move <b>L‚ÇÄ</b> to see the curve stretch left and right.<br>
‚Ä¢ Move <b>A</b> to make the curve taller or shorter.<br>
‚Ä¢ Move <b>n</b> to make the curve ‚Äúsharper‚Äù or ‚Äúsofter‚Äù.<br>
‚Ä¢ Move <b>R<sub>max</sub></b> to zoom in and out horizontally.<br>
‚Ä¢ Move <b>d</b> toward 1.0 to mix in more derivative (slope) information.<br>
‚Ä¢ Press <b>Start Particle</b> to see a point slide along the curve according
  to the local slope.
<br><br>
<b>For advanced users / PhDs:</b><br>
Think of this as a toy model of a 1D potential profile where STUR‚Äôs
resistance geometry is encoded in S(r) and its variations. The particle
motion here uses
<code>F(r) ‚âà ‚àí d/dr [S<sub>blend</sub>(r)]</code> with unit mass, so acceleration
tracks the local slope of the blended field. Sliders let you explore how
geometry and effective curvature interact.
  </p>
</div>

<div class="panel">
  <h2>STUR Map (Conceptual)</h2>
  <pre>
Energy + Information
        ‚Üì
   Resistance Geometry  S(r)
        ‚Üì
   Curvature / Slope  dS/dr
        ‚Üì
       Force  F(r)
        ‚Üì
      Motion
  </pre>
  <p class="text">
This sandbox sits at the middle of that chain: it lets you play with geometry
S(r), its deformation, and the resulting slope that drives motion.
  </p>
</div>

<!-- ===================================================== -->
<!-- LINKS -->
<!-- ===================================================== -->
<div class="links">
  <a href="../index.html">‚Üê STUR Physics Lab</a>
  <a href="https://x.com/that1sheldon" target="_blank">‚ú¶ X</a>
  <a href="https://www.tiktok.com/@that1sheldon" target="_blank">üéµ TikTok</a>
  <a href="https://github.com/sheldonlindberg-afk/STUR-Physics-Lab" target="_blank">‚öõ GitHub</a>
</div>

<!-- ===================================================== -->
<!-- JAVASCRIPT ‚Äì ALL FUNCTIONAL -->
<!-- ===================================================== -->
<script>
// ---------- Base STUR functions ----------
function S_base(r, L0) {
  const x = r / L0;
  return Math.tanh(x) * (1 - Math.exp(-x));
}

// Analytic derivative of the base STUR S(r)
function S_prime(r, L0) {
  const x = r / L0;
  const sech2 = 1 / Math.cosh(x)**2;
  return (sech2*(1 - Math.exp(-x)) + Math.tanh(x)*Math.exp(-x)) / L0;
}

// Modified STUR with amplitude + exponent
function S_mod(r, L0, A, n) {
  const x = r / L0;
  const t = Math.tanh(x);
  return A * (t**n) * (1 - Math.exp(-x));
}

// Blended field used for plotting + motion
function S_blend(r, L0, A, n, d) {
  const Sm = S_mod(r, L0, A, n);
  const Sprime = S_prime(r, L0);
  return (1 - d)*Sm + d*Sprime;
}

// Numerical derivative of blended field
function dS_blend_dr(r, L0, A, n, d) {
  const h = 1e-3 * Math.max(1, L0);
  const r1 = Math.max(0, r - h);
  const r2 = r + h;
  const f1 = S_blend(r1, L0, A, n, d);
  const f2 = S_blend(r2, L0, A, n, d);
  return (f2 - f1) / (r2 - r1);
}

// ---------- DOM elements ----------
const L0_slider   = document.getElementById("L0");
const A_slider    = document.getElementById("A");
const n_slider    = document.getElementById("n");
const Rmax_slider = document.getElementById("Rmax");
const blend_slider= document.getElementById("blend");

const L0_val   = document.getElementById("L0_val");
const A_val    = document.getElementById("A_val");
const n_val    = document.getElementById("n_val");
const Rmax_val = document.getElementById("Rmax_val");
const d_val    = document.getElementById("d_val");

const outputEl     = document.getElementById("output");
const canvas       = document.getElementById("plot");
const ctx          = canvas.getContext("2d");
const toggleAnimBtn= document.getElementById("toggleAnim");
const resetBtn     = document.getElementById("resetBtn");
const downloadBtn  = document.getElementById("downloadBtn");

// ---------- Particle state ----------
let particle = {
  r: parseFloat(Rmax_slider.value) / 2,  // start in middle
  v: 0.0
};
let animating = false;

// ---------- Main update: sliders ‚Üí curve + text ----------
function update() {
  const L0   = parseFloat(L0_slider.value);
  const A    = parseFloat(A_slider.value);
  const n    = parseFloat(n_slider.value);
  const Rmax = parseFloat(Rmax_slider.value);
  const d    = parseFloat(blend_slider.value);

  // Clamp particle inside new range if Rmax changed
  if (particle.r > Rmax) particle.r = Rmax;

  // Update labels
  L0_val.textContent   = L0.toFixed(2);
  A_val.textContent    = A.toFixed(2);
  n_val.textContent    = n.toFixed(2);
  Rmax_val.textContent = Rmax.toFixed(1);
  d_val.textContent    = d.toFixed(2);

  // Draw curve + particle
  drawScene(L0, A, n, Rmax, d);

  // Sample at particle position
  const rp    = particle.r;
  const Sraw  = S_base(rp, L0);
  const Smod  = S_mod(rp, L0, A, n);
  const Sblend= S_blend(rp, L0, A, n, d);
  const Spr   = S_prime(rp, L0);
  const slope = dS_blend_dr(rp, L0, A, n, d);
  const F     = -slope;  // unit mass

  outputEl.textContent =
`Sliders:
  L‚ÇÄ      = ${L0.toFixed(2)}
  A       = ${A.toFixed(2)}
  n       = ${n.toFixed(2)}
  Rmax    = ${Rmax.toFixed(2)}
  d       = ${d.toFixed(2)}

Probe at particle position r = ${rp.toFixed(3)}:

  Base STUR:
    S_base(r)    = ${Sraw.toFixed(6)}
    S'_base(r)   = ${Spr.toFixed(6)}

  Modified field:
    S_mod(r)     = ${Smod.toFixed(6)}

  Blended field:
    S_blend(r)   = ${Sblend.toFixed(6)}
    d/dr S_blend = ${slope.toExponential(6)}

  1D toy force (unit mass):
    F(r) ‚âà ‚àí d/dr S_blend(r)
         = ${F.toExponential(6)}

Interpretation:
  ‚Ä¢ The curve on the canvas is S_blend(r).
  ‚Ä¢ All sliders change the geometry of this curve.
  ‚Ä¢ The particle moves according to the local slope (force ~ ‚àídS/dr).`;
}

// ---------- Drawing ----------
function drawScene(L0, A, n, Rmax, d) {
  const W = canvas.width;
  const H = canvas.height;
  ctx.clearRect(0, 0, W, H);

  // Draw center axis (y = 0 reference)
  ctx.strokeStyle = "#444";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, H/2);
  ctx.lineTo(W, H/2);
  ctx.stroke();

  // Draw blended curve
  ctx.strokeStyle = "#ffaa00";
  ctx.lineWidth = 2;
  ctx.beginPath();

  for (let i = 0; i <= W; i++) {
    const r = (i / W) * Rmax;
    let val = S_blend(r, L0, A, n, d);

    // Clamp for display so extremes don't blow it out
    if (val > 1.2) val = 1.2;
    if (val < -1.2) val = -1.2;

    const y = H/2 - val * (H * 0.4);
    if (i === 0) ctx.moveTo(i, y);
    else ctx.lineTo(i, y);
  }
  ctx.stroke();

  // Draw particle as a small cyan dot on the curve
  let r_p = particle.r;
  if (r_p < 0) r_p = 0;
  if (r_p > Rmax) r_p = Rmax;

  let val_p = S_blend(r_p, L0, A, n, d);
  if (val_p > 1.2) val_p = 1.2;
  if (val_p < -1.2) val_p = -1.2;
  const x = (r_p / Rmax) * W;
  const y_p = H/2 - val_p * (H * 0.4);

  ctx.fillStyle = "#00ffcc";
  ctx.beginPath();
  ctx.arc(x, y_p, 6, 0, 2*Math.PI);
  ctx.fill();
}

// ---------- Particle animation ----------
let lastTime = null;

function stepParticle(L0, A, n, Rmax, d, dt) {
  // 1D toy force: F ~ ‚àí dS_blend/dr (unit mass)
  const slope = dS_blend_dr(particle.r, L0, A, n, d);
  const a = -slope;

  particle.v += a * dt;
  particle.r += particle.v * dt;

  // Keep particle within [0, Rmax] with soft reflection
  if (particle.r < 0) {
    particle.r = 0;
    particle.v *= -0.4;
  } else if (particle.r > Rmax) {
    particle.r = Rmax;
    particle.v *= -0.4;
  }
}

function animate(timestamp) {
  if (!animating) return;
  const L0   = parseFloat(L0_slider.value);
  const A    = parseFloat(A_slider.value);
  const n    = parseFloat(n_slider.value);
  const Rmax = parseFloat(Rmax_slider.value);
  const d    = parseFloat(blend_slider.value);

  // fixed small dt, independent of frame rate
  const dt = 0.03;
  for (let i = 0; i < 4; i++) {
    stepParticle(L0, A, n, Rmax, d, dt);
  }
  update();
  requestAnimationFrame(animate);
}

// ---------- Event handlers ----------
[L0_slider, A_slider, n_slider, Rmax_slider, blend_slider].forEach(sl => {
  sl.addEventListener("input", () => {
    // geometry changes ‚Üí just update
    update();
  });
});

toggleAnimBtn.addEventListener("click", () => {
  animating = !animating;
  if (animating) {
    toggleAnimBtn.textContent = "‚è∏ Pause Particle";
    lastTime = null;
    requestAnimationFrame(animate);
  } else {
    toggleAnimBtn.textContent = "‚ñ∂ Start Particle";
  }
});

resetBtn.addEventListener("click", () => {
  L0_slider.value   = 1;
  A_slider.value    = 1;
  n_slider.value    = 1;
  Rmax_slider.value = 5;
  blend_slider.value= 0;
  particle.r = parseFloat(Rmax_slider.value) / 2;
  particle.v = 0.0;
  animating = false;
  toggleAnimBtn.textContent = "‚ñ∂ Start Particle";
  update();
});

downloadBtn.addEventListener("click", () => {
  const L0   = parseFloat(L0_slider.value);
  const A    = parseFloat(A_slider.value);
  const n    = parseFloat(n_slider.value);
  const Rmax = parseFloat(Rmax_slider.value);
  const d    = parseFloat(blend_slider.value);

  const N = 200;
  const points = [];
  for (let i = 0; i <= N; i++) {
    const r = (i / N) * Rmax;
    const Sbase = S_base(r, L0);
    const Smodv = S_mod(r, L0, A, n);
    const Sder  = S_prime(r, L0);
    const Sbl   = S_blend(r, L0, A, n, d);
    points.push({
      r: r,
      S_base: Sbase,
      S_mod: Smodv,
      S_prime: Sder,
      S_blend: Sbl
    });
  }

  const data = {
    L0, A, n, Rmax, d,
    description: "STUR sandbox curve: base, modified, derivative, blended.",
    points
  };

  const blob = new Blob([JSON.stringify(data, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "stur_sandbox_curve.json";
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
});

// ---------- Initial render ----------
update();
</script>

</body>
</html>
