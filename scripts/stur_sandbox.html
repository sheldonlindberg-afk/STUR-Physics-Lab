<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STUR Sandbox – Geometry, Simulation & Motion</title>

<style>
  body {
    background:#050814;
    color:#e6edf3;
    font-family:'Courier New', monospace;
    margin:0;
    padding:1.5rem;
  }
  h1 { text-align:center; color:#ffaa00; margin-bottom:0.75rem; }
  h2 { color:#ffcc33; margin-top:1rem; }
  .panel {
    background:#0a0f1f;
    padding:1rem;
    border-radius:8px;
    max-width:900px;
    margin:1rem auto;
    box-shadow:0 0 12px #ffaa0044;
  }
  .text {
    max-width:900px;
    margin:0 auto;
    line-height:1.5;
  }
  label { display:block; margin-top:10px; font-size:0.9rem; }
  input[type=range] { width:100%; }
  canvas {
    width:100%;
    height:260px;
    background:#000;
    border-radius:6px;
    margin-top:0.75rem;
    display:block;
  }
  button {
    background:#ffaa00;
    color:#050814;
    border:none;
    border-radius:6px;
    padding:8px 12px;
    margin:4px;
    cursor:pointer;
    font-family:'Courier New', monospace;
    font-size:0.85rem;
    white-space:nowrap;
  }
  button:hover { background:#ffcc33; }
  pre {
    white-space:pre-wrap;
    color:#00ffcc;
    font-size:0.8rem;
    overflow-x:auto;
  }
  code { color:#5ad0ff; }

  .controls-row {
    display:flex;
    flex-wrap:wrap;
    gap:8px;
    align-items:center;
    margin-top:0.5rem;
  }
  .controls-column {
    flex:1 1 180px;
    min-width:0;
  }
  .buttons-column {
    flex:1 1 160px;
    display:flex;
    flex-wrap:wrap;
    justify-content:flex-start;
  }

  .energy-wrap {
    margin-top:0.5rem;
    font-size:0.75rem;
  }
  .energy-bar {
    background:#111;
    border-radius:4px;
    overflow:hidden;
    height:10px;
    margin-top:4px;
  }
  .energy-inner {
    height:100%;
    width:0%;
    background:#00ffcc;
    transition:width 0.1s linear;
  }

  details summary {
    cursor:pointer;
    color:#ffcc33;
    margin-bottom:0.25rem;
  }

  @media (max-width:600px) {
    body { padding:1rem; }
    .panel { padding:0.8rem; }
    button { flex:1 1 45%; text-align:center; }
  }
</style>
</head>
<body>

<h1>STUR Geometry Sandbox</h1>

<!-- ===================================================== -->
<!-- EDUCATIONAL SECTION – FULL & EXPANDED -->
<!-- ===================================================== -->

<div class="panel">
  <h2>What This Sandbox Shows</h2>
  <p class="text">
This sandbox is a live experiment in STUR-style geometry. The field is
defined by a simple radial function:
<br><br>
<code>S(r) = tanh(r / L₀) · (1 − e<sup>−r / L₀</sup>)</code>
<br><br>
A single particle is placed on this curve and allowed to move according to an
approximate force:
<br><br>
<code>F(r) ≈ − dS/dr</code>
<br><br>
Changing <code>L₀</code> stretches or compresses the geometry, and changing
<code>R<sub>max</sub></code> zooms the visible domain. The particle feels those changes
as it slides along the curve.
  </p>
</div>

<div class="panel">
  <h2>Iteration: How Real Science Moves</h2>
  <p class="text">
Science is not a straight line from question to answer. It looks like:
<br><br>
<b>guess → simulate → compare → refine → repeat</b>.
<br><br>
This page is designed for rapid iteration. Adjust a slider, start the motion,
see how the system behaves, and adjust again. There is no penalty for trying
things that do not work. That is the point.
  </p>
</div>

<div class="panel">
  <h2>Why Simulations Matter</h2>
  <p class="text">
Simulations are useful because they let you explore “what if” scenarios that
are too expensive, too dangerous, or too slow to test directly. A good
simulation does not replace experiments; it narrows down which experiments
are worth doing, and helps make sense of what experiments show.
  </p>
</div>

<div class="panel">
  <h2>A Short History of Simulations</h2>
  <p class="text">
Early simulations were done with pencil and paper and mechanical devices.
With digital computers, simulations evolved from simple orbits and fluid
approximations to high-resolution climate models, galaxy formation,
particle collisions, and biological networks.
<br><br>
This sandbox sits at the simple end of that spectrum: a one-dimensional
geometry curve with a particle responding to its slope. The goal is not to be
complete, but to be understandable and modifiable.
  </p>
</div>

<div class="panel">
  <h2>Python, Code, and Thinking in Equations</h2>
  <p class="text">
Writing Python code for simulations is a way to turn equations into motion.
At a basic level, most simulation scripts follow the same pattern:
<br><br>
1. <b>Define the field</b> (like <code>S(r)</code>).<br>
2. <b>Define how things respond</b> (forces, slopes, accelerations).<br>
3. <b>Update step-by-step</b> using a small time step <code>dt</code>. <br>
4. <b>Record and plot</b> positions, velocities, energies, or other observables.
<br><br>
The data downloaded from this sandbox can be fed into a Python script or
Jupyter notebook to make additional plots, check stability, or compare with
other models.
  </p>
</div>

<div class="panel">
  <h2>From Sandbox to Python (Starter Template)</h2>
  <p class="text">
The button at the bottom of the page exports the current curve as JSON. The
following Python starter shows how to load that file and plot
<code>S(r)</code>:
  </p>
  <pre>
import json
import matplotlib.pyplot as plt

# 1. Load data exported from the STUR sandbox
with open("stur_sandbox_curve.json","r") as f:
    data = json.load(f)

r_vals   = [pt["r"] for pt in data["points"]]
S_vals   = [pt["S"] for pt in data["points"]]

# 2. Plot the curve
plt.style.use("dark_background")
plt.figure(figsize=(6,4))
plt.plot(r_vals, S_vals, label="S(r) from STUR sandbox")
plt.xlabel("r")
plt.ylabel("S(r)")
plt.legend()
plt.tight_layout()
plt.show()
  </pre>
  <p class="text">
This pattern can be extended to overlay analytic curves, track trajectories,
or compare different choices of <code>L₀</code>.
  </p>
</div>

<div class="panel">
  <h2>AI as a Simulation Partner</h2>
  <p class="text">
AI tools can help with:
<br><br>
• Translating equations into code.<br>
• Checking derivations and logic.<br>
• Suggesting numerical methods and stability improvements.<br>
• Explaining unfamiliar functions or symbols.
<br><br>
They are not a replacement for understanding, but they can reduce friction
when turning ideas into working simulations.
  </p>
</div>

<div class="panel">
  <h2>STUR Geometry Map</h2>
  <pre>
Energy + Information
        ↓
   Resistance Geometry  S(r)
        ↓
        Slope  dS/dr
        ↓
       Force  F(r)
        ↓
      Motion  r(t)
  </pre>
  <p class="text">
This sandbox focuses on the middle of this chain: geometry, slope, and motion.
The sliders set the geometry; the curve shows S(r); the particle visualizes r(t).
  </p>
</div>

<!-- ===================================================== -->
<!-- INTERACTIVE SANDBOX: CONTROLS + GRAPH TOGETHER -->
<!-- ===================================================== -->

<div class="panel">
  <h2>Interactive STUR Sandbox</h2>
  <p class="text">
Use the controls to shape the curve and then let the particle move. The kick
button pushes the particle away from the nearest wall so it does not get stuck.
  </p>

  <div class="controls-row">
    <div class="controls-column">
      <label>L₀ (geometry scale): <span id="L0_val">1.00</span></label>
      <input type="range" id="L0" min="0.2" max="3" value="1" step="0.1">

      <label>R<sub>max</sub> (horizontal range): <span id="Rmax_val">5.0</span></label>
      <input type="range" id="Rmax" min="2" max="10" value="5" step="0.5">
    </div>

    <div class="buttons-column">
      <button id="toggleAnim">▶ Start</button>
      <button id="kickBtn">⚡ Kick</button>
      <button id="resetBtn">⟲ Reset</button>
      <button id="downloadBtn">⬇ Download Curve</button>
    </div>
  </div>

  <canvas id="plot" width="800" height="260"></canvas>

  <div class="energy-wrap">
    Speed indicator (relative):
    <div class="energy-bar">
      <div id="speed_bar" class="energy-inner"></div>
    </div>
  </div>

  <details style="margin-top:0.5rem;">
    <summary>Show live numerical output</summary>
    <pre id="output"></pre>
  </details>
</div>

<script>
// ---------- STUR field ----------
function S(r, L0) {
  const x = r / L0;
  return Math.tanh(x) * (1 - Math.exp(-x));
}
function dS_dr(r, L0) {
  const h = 1e-3 * Math.max(1, L0);
  const r1 = Math.max(0, r - h);
  const r2 = r + h;
  const f1 = S(r1, L0);
  const f2 = S(r2, L0);
  return (f2 - f1) / (r2 - r1);
}

// ---------- DOM ----------
const L0_slider   = document.getElementById("L0");
const Rmax_slider = document.getElementById("Rmax");
const L0_val      = document.getElementById("L0_val");
const Rmax_val    = document.getElementById("Rmax_val");
const canvas      = document.getElementById("plot");
const ctx         = canvas.getContext("2d");
const outputEl    = document.getElementById("output");
const toggleBtn   = document.getElementById("toggleAnim");
const kickBtn     = document.getElementById("kickBtn");
const resetBtn    = document.getElementById("resetBtn");
const downloadBtn = document.getElementById("downloadBtn");
const speedBar    = document.getElementById("speed_bar");

// ---------- particle ----------
let particle = { r: 2.5, v: 0.0 };
let animating = false;
let trail = [];

// ---------- update ----------
function update() {
  const L0   = parseFloat(L0_slider.value);
  const Rmax = parseFloat(Rmax_slider.value);

  if (particle.r > Rmax) particle.r = Rmax;

  L0_val.textContent   = L0.toFixed(2);
  Rmax_val.textContent = Rmax.toFixed(1);

  drawScene(L0, Rmax);

  const slope = dS_dr(particle.r, L0);
  const F     = -slope;
  const speed = Math.abs(particle.v);
  const speedRel = Math.min(1, speed / 3.0); // scale for bar

  speedBar.style.width = (speedRel * 100).toFixed(1) + "%";

  outputEl.textContent =
`Parameters:
  L₀    = ${L0.toFixed(2)}
  Rmax  = ${Rmax.toFixed(2)}

Particle:
  r     = ${particle.r.toFixed(3)}
  v     = ${particle.v.toFixed(3)}
  |v|   = ${speed.toFixed(3)}
  slope = ${slope.toExponential(3)}
  F ≈ -dS/dr = ${F.toExponential(3)}

Interpretation:
  • The yellow curve is S(r).
  • L₀ stretches/compresses the geometry.
  • Rmax sets the visible range.
  • The particle slides according to the slope, with gentle damping.`;
}

// ---------- draw ----------
function drawScene(L0, Rmax) {
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0,0,W,H);

  // baseline
  ctx.strokeStyle="#333";
  ctx.lineWidth=1;
  ctx.beginPath();
  ctx.moveTo(0,H/2); ctx.lineTo(W,H/2); ctx.stroke();

  // STUR curve
  ctx.strokeStyle="#ffaa00";
  ctx.lineWidth=2;
  ctx.beginPath();
  for (let i=0;i<=W;i++){
    const r=(i/W)*Rmax;
    let val=S(r,L0);
    val=Math.max(-1.2,Math.min(1.2,val));
    const y=H/2 - val*(H*0.4);
    if(i===0)ctx.moveTo(i,y); else ctx.lineTo(i,y);
  }
  ctx.stroke();

  // trail
  if(trail.length>1){
    for(let i=1;i<trail.length;i++){
      const r1=trail[i-1], r2=trail[i];
      const x1=(r1/Rmax)*W, x2=(r2/Rmax)*W;
      const y1=H/2 - S(r1,L0)*(H*0.4);
      const y2=H/2 - S(r2,L0)*(H*0.4);
      const alpha=i/trail.length*0.5;
      ctx.strokeStyle=`rgba(0,255,204,${alpha.toFixed(3)})`;
      ctx.lineWidth=1.5;
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
    }
  }

  // particle
  const rp=Math.max(0,Math.min(Rmax,particle.r));
  const xp=(rp/Rmax)*W;
  const yp=H/2 - S(rp,L0)*(H*0.4);

  ctx.fillStyle="#00ffcc";
  ctx.beginPath();
  ctx.arc(xp,yp,6,0,2*Math.PI);
  ctx.fill();
}

// ---------- physics ----------
function step(L0,Rmax,dt=0.02){
  const slope=dS_dr(particle.r,L0);
  const F=-slope;
  const damping=0.05;
  particle.v += (F - damping*particle.v)*dt;
  particle.r += particle.v*dt;

  if(particle.r<0){ particle.r=0; particle.v*=-0.4; }
  if(particle.r>Rmax){ particle.r=Rmax; particle.v*=-0.4; }

  trail.push(particle.r);
  if(trail.length>200) trail.shift();
}

// ---------- animate ----------
function animate(){
  if(!animating)return;
  const L0=parseFloat(L0_slider.value);
  const Rmax=parseFloat(Rmax_slider.value);
  for(let i=0;i<3;i++) step(L0,Rmax);
  update();
  requestAnimationFrame(animate);
}

// ---------- events ----------
L0_slider.addEventListener("input",update);
Rmax_slider.addEventListener("input",update);

toggleBtn.onclick = () => {
  animating=!animating;
  toggleBtn.textContent=animating?"⏸ Pause":"▶ Start";
  if(animating) requestAnimationFrame(animate);
};

kickBtn.onclick = () => {
  const Rmax=parseFloat(Rmax_slider.value);
  const center=Rmax/2;
  const dir = (particle.r <= center) ? 1 : -1; // away from nearest wall
  const kickMag = 1.0 + Math.random()*0.7;
  particle.v = dir * kickMag;
  update();
};

resetBtn.onclick = () => {
  L0_slider.value   = 1;
  Rmax_slider.value = 5;
  particle.r=2.5;
  particle.v=0;
  trail=[];
  animating=false;
  toggleBtn.textContent="▶ Start";
  update();
};

downloadBtn.onclick = () => {
  const L0   = parseFloat(L0_slider.value);
  const Rmax = parseFloat(Rmax_slider.value);
  const N    = 200;
  const points = [];
  for(let i=0;i<=N;i++){
    const r=(i/N)*Rmax;
    points.push({ r:r, S:S(r,L0) });
  }
  const payload = { L0, Rmax, points };
  const blob = new Blob([JSON.stringify(payload,null,2)], {type:"application/json"});
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement("a");
  a.href = url;
  a.download = "stur_sandbox_curve.json";
  a.click();
  URL.revokeObjectURL(url);
};

// ---------- initial render ----------
update();
</script>

</body>
</html>
