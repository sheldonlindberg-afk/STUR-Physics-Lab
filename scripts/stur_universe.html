<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>STUR Universe Atlas ‚Äì Earth POV Skybox (Full Helix Flow v5.0)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
  :root {
    --bg-main: #02030a;
    --bg-panel: #050814;
    --bg-panel-alt: #080c1f;
    --accent: #ffb347;
    --accent-2: #00d4ff;
    --accent-soft: rgba(0,212,255,0.25);
    --text-main: #e6edf3;
    --text-muted: #9caecb;
    --border-soft: #1b2538;
    --code-bg: #050711;
  }

  * { box-sizing: border-box; }

  body {
    margin: 0;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    background:
      radial-gradient(circle at 12% 15%, #111936 0, #02030a 40%),
      radial-gradient(circle at 80% 80%, #00111f 0, #02030a 55%);
    color: var(--text-main);
    line-height: 1.6;
  }

  a { color: var(--accent-2); text-decoration: none; }
  a:hover { text-decoration: underline; }

  header {
    padding: 56px 16px 20px;
    text-align: center;
  }

  .logo-row {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    margin-bottom: 4px;
  }
  .logo-mark {
    width: 40px;
    height: 40px;
    border-radius: 999px;
    border: 1px solid var(--accent-soft);
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    letter-spacing: 0.12em;
    font-size: 11px;
    text-transform: uppercase;
    background: radial-gradient(circle at 30% 20%, #1e2847, #050814);
    box-shadow: 0 0 18px rgba(0,212,255,0.35);
  }
  .logo-text {
    font-size: 13px;
    text-transform: uppercase;
    letter-spacing: 0.24em;
    color: var(--text-muted);
  }

  h1 {
    margin: 10px 0 6px;
    font-size: clamp(1.7rem, 4vw, 2.3rem);
  }
  .tagline {
    margin-top: 6px;
    color: var(--text-muted);
    font-size: 0.98rem;
  }

  .badge-row {
    margin-top: 18px;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 6px;
  }
  .badge {
    font-size: 0.72rem;
    text-transform: uppercase;
    letter-spacing: 0.14em;
    padding: 3px 8px;
    border-radius: 999px;
    border: 1px solid var(--border-soft);
    background: rgba(5,10,28,0.85);
    color: var(--text-muted);
  }
  .badge.accent {
    border-color: var(--accent-2);
    color: var(--accent-2);
    background: rgba(0,212,255,0.08);
  }

  main {
    max-width: 1080px;
    margin: 0 auto 40px;
    padding: 0 16px 40px;
  }

  .panel {
    background: radial-gradient(circle at 15% 0, #10182f, #050814);
    border-radius: 14px;
    border: 1px solid var(--border-soft);
    padding: 18px 18px 16px;
    margin-bottom: 28px;
    box-shadow: 0 0 30px rgba(0,0,0,0.6);
  }
  .panel.alt {
    background: radial-gradient(circle at 80% 10%, #07142d, #050814);
  }
  .panel-header {
    display: flex;
    align-items: baseline;
    justify-content: space-between;
    gap: 8px;
    margin-bottom: 4px;
  }
  .panel-title {
    font-size: 1rem;
    font-weight: 600;
  }
  .panel-tag {
    font-size: 0.75rem;
    color: var(--text-muted);
  }

  .grid-two {
    display: grid;
    grid-template-columns: minmax(0,2fr) minmax(0,2fr);
    gap: 14px;
  }
  @media (max-width: 800px) {
    .grid-two {
      grid-template-columns: minmax(0,1fr);
    }
  }

  ul {
    padding-left: 18px;
    margin-top: 6px;
    margin-bottom: 6px;
  }
  li { margin-bottom: 3px; }

  code {
    font-family: "JetBrains Mono", "SF Mono", Menlo, Monaco, Consolas, "Courier New", monospace;
    font-size: 0.85rem;
  }

  .inline-math {
    font-family: "Latin Modern Math", "STIX Two Math", "Times New Roman", serif;
    font-style: italic;
  }

  .equation-block {
    margin: 8px 0;
    padding: 8px 10px;
    border-radius: 10px;
    background: rgba(4,9,24,0.95);
    border: 1px solid rgba(255,255,255,0.04);
    font-family: "Latin Modern Math", "STIX Two Math", "Times New Roman", serif;
    font-size: 0.92rem;
  }

  .steps {
    list-style: decimal;
    padding-left: 20px;
    margin-top: 6px;
  }
  .steps li { margin-bottom: 5px; }

  .code-shell {
    margin-top: 4px;
    background: radial-gradient(circle at 0 0, #202744, #050711);
    border-radius: 14px;
    border: 1px solid #262f4d;
    overflow: hidden;
  }
  .code-shell-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 10px;
    border-bottom: 1px solid #262f4d;
    font-size: 0.78rem;
    color: var(--text-muted);
  }
  .code-shell-header-left {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .dot {
    width: 9px;
    height: 9px;
    border-radius: 50%;
    background: #ff5f57;
  }
  .dot:nth-child(2) { background: #febc2e; }
  .dot:nth-child(3) { background: #28c840; }
  .code-filename {
    color: #9fb4ff;
    font-family: "JetBrains Mono", monospace;
  }

  .code-actions {
    display: flex;
    gap: 8px;
  }

  .btn-inline {
    padding: 4px 8px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.18);
    background: rgba(3,7,18,0.7);
    color: var(--text-main);
    font-size: 0.75rem;
    cursor: pointer;
  }
  .btn-inline:hover {
    background: rgba(0,212,255,0.12);
    border-color: var(--accent-2);
  }

  textarea#sturCode {
    width: 100%;
    border: none;
    padding: 12px 14px;
    margin: 0;
    resize: vertical;
    min-height: 440px;
    max-height: 1800px;
    color: #e8f0ff;
    background: var(--code-bg);
    font-family: "JetBrains Mono", monospace;
    font-size: 0.82rem;
    line-height: 1.45;
    tab-size: 4;
    overflow: auto;
    outline: none;
    white-space: pre;
  }

  @media (max-width: 600px) {
    textarea#sturCode {
      font-size: 0.72rem;
      padding: 10px;
    }
  }

  .button-row {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 18px;
    justify-content: center;
  }
  .btn {
    border-radius: 999px;
    border: 1px solid var(--border-soft);
    padding: 8px 14px;
    font-size: 0.85rem;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 6px;
    background: rgba(5,8,20,0.9);
    color: var(--text-main);
    text-decoration: none;
    white-space: nowrap;
  }
  .btn.primary {
    border-color: var(--accent-2);
    background: radial-gradient(circle at 0 0, #0c2334, #050814);
    box-shadow: 0 0 16px rgba(0,212,255,0.35);
  }
  .btn.accent {
    border-color: var(--accent);
    background: radial-gradient(circle at 0 0, #24160a, #050814);
  }
  .btn:hover {
    transform: translateY(-0.5px);
    box-shadow: 0 0 12px rgba(0,0,0,0.6);
  }

  .footer-nav {
    margin-top: 24px;
    padding-top: 14px;
    border-top: 1px solid var(--border-soft);
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    justify-content: space-between;
    align-items: center;
    font-size: 0.8rem;
    color: var(--text-muted);
  }
  .footer-nav .left,
  .footer-nav .right {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
  }

  .chip {
    border-radius: 999px;
    border: 1px solid var(--border-soft);
    padding: 3px 8px;
    font-size: 0.75rem;
    background: rgba(3,7,18,0.9);
  }

  .tiny { font-size: 0.75rem; color: var(--text-muted); }

  .highlight-pill {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    border-radius: 999px;
    padding: 4px 10px;
    border: 1px solid rgba(0,212,255,0.35);
    background: rgba(0,212,255,0.06);
    font-size: 0.78rem;
    color: var(--accent-2);
  }

  .scroll-top {
    position: fixed;
    right: 14px;
    bottom: 14px;
    border-radius: 999px;
    border: 1px solid rgba(0,212,255,0.35);
    background: rgba(3,7,18,0.95);
    padding: 6px 9px;
    font-size: 0.78rem;
    cursor: pointer;
    display: none;
    z-index: 50;
  }
  .scroll-top.show { display: inline-flex; }
</style>
</head>

<body>
<header id="top">
  <div class="logo-row">
    <div class="logo-mark">STUR</div>
    <div class="logo-text">Physics Lab</div>
  </div>
  <h1>STUR Universe Atlas ‚Äì Earth POV Skybox (Full Helix Flow v5.0)</h1>
  <div class="tagline">
    A full 4œÄ skybox from Earth: Local Group, clusters, walls, voids, JWST fields,
    and a STUR coherence fog, all stitched into one helix atlas.
  </div>
  <div class="badge-row">
    <span class="badge accent">Earth POV ¬∑ Full Skybox</span>
    <span class="badge">3D Helix Skeleton ¬∑ Aitoff Projection ¬∑ 6-Face Atlas</span>
    <span class="badge">JupyterLite / Pyodide Safe</span>
    <span class="badge">JSON Catalog for All Helices</span>
  </div>
</header>

<main>

  <!-- OVERVIEW / DERIVATION -->
  <section class="panel">
    <div class="panel-header">
      <div class="panel-title">What this Universe Atlas actually does</div>
      <div class="panel-tag">First STUR Earth-POV skybox ¬∑ Full helix atlas</div>
    </div>
    <div class="grid-two">
      <div>
        <p>
          This lab builds a <strong>STUR Universe Atlas</strong> from the point of view of Earth.
          You sit at the origin. Every point in the sky is given:
        </p>
        <ul>
          <li>a direction on the celestial sphere \((\alpha,\delta)\) in RA/Dec,</li>
          <li>a comoving distance in megaparsecs (Mpc) from a flat ŒõCDM model,</li>
          <li>a STUR coherence weight \(S(r)\), and</li>
          <li>optional <strong>helix funnels</strong> for major structures.</li>
        </ul>
        <p>The STUR coherence profile is</p>
        <div class="equation-block">
          \( S(r) = \tanh\!\big(x\big)\,\big(1 - e^{-x}\big),\quad x = \dfrac{r}{L_0} \)
        </div>
        <p>
          where \(r\) is comoving distance and \(L_0\) is a coherence scale tied to the
          structure (cluster, void, wall, or supercluster). Large \(S\) means the universe
          "likes" to store or move energy along that radial scale.
        </p>
        <p>
          Each major structure gets a central <strong>helix funnel</strong> launched from Earth.
          Let \(\hat{a}\) be the unit vector from Earth to the structure. We build an orthonormal
          triad \(\{\hat{a},\hat{e}_1,\hat{e}_2\}\) and trace
        </p>
        <div class="equation-block">
          \( \vec{r}(s) = r(s)\,\hat{a}
          + R_{\rm helix}(s)\big[\cos\Phi(s)\,\hat{e}_1 + \sin\Phi(s)\,\hat{e}_2\big],\quad s\in[0,1], \)
        </div>
        <p>
          with \(r(s)\) running from 0 to the structure distance, and
          \(R_{\rm helix}(s)\) modulated by \(S(r)\). Repellers and voids reuse the same
          machinery but with <strong>opening</strong> rather than focusing envelopes.
        </p>
      </div>
      <div>
        <p><strong>Cosmology, distance ladder, and skybox mapping</strong></p>
        <p>We use a flat ŒõCDM background:</p>
        <div class="equation-block">
          \( H(z) = H_0\sqrt{\Omega_m(1+z)^3 + \Omega_\Lambda} \)
        </div>
        <p>
          with \(H_0 = 70\,\mathrm{km/s/Mpc}\), \(\Omega_m = 0.3\),
          \(\Omega_\Lambda = 0.7\). The comoving distance is
        </p>
        <div class="equation-block">
          \( D_C(z) = \displaystyle \int_0^z \dfrac{c\,dz'}{H(z')} \),
        </div>
        <p>
          computed numerically with a tabulated integral and linear interpolation up to \(z=20\).
          The inverse \(z(D_C)\) lets us color the fog by approximate redshift.
        </p>
        <p><strong>From RA/Dec to a 4œÄ skybox</strong></p>
        <p>
          Directions on the sky are encoded as unit vectors
          \( \hat{n}(\alpha,\delta) = (\cos\delta\cos\alpha,\ \cos\delta\sin\alpha,\ \sin\delta) \).
          To make a game-style cube-map skybox, each direction is projected onto one of six faces:
          FRONT (+X), BACK (‚àíX), LEFT (+Y), RIGHT (‚àíY), TOP (+Z), BOTTOM (‚àíZ).
          Each face gets \((u,v)\) in [-1,1]\(\times\)[-1,1], and we draw helix paths and
          STUR fog inside a circular field of view.
        </p>
        <p class="tiny">
          You can think of this as a <strong>STUR-ready atlas</strong> that you could feed
          into a WebGL viewer, VR dome, or game engine later.
        </p>
      </div>
    </div>
  </section>

  <!-- HOW TO RUN -->
  <section class="panel alt">
    <div class="panel-header">
      <div class="panel-title">How to run the STUR Universe Atlas</div>
      <div class="panel-tag">JupyterLite / Pyodide ¬∑ Desktop Python</div>
    </div>
    <div class="grid-two">
      <div>
        <p><strong>Option A ‚Äì Run in the browser (JupyterLite / Pyodide)</strong></p>
        <ol class="steps">
          <li>Open a JupyterLite / Pyodide notebook environment in your browser.</li>
          <li>Create a new <strong>Python 3</strong> notebook.</li>
          <li>Scroll down, click <strong>‚ÄúCopy STUR Universe Atlas Code‚Äù</strong>.</li>
          <li>Paste into a single notebook cell.</li>
          <li>Run the cell. It will:
            <ul>
              <li>Print a small <code>"Start running..."</code> status line.</li>
              <li>Draw three figures:
                <ul>
                  <li>3D helix skeleton (fog + funnels + Earth rays + CMB arrow)</li>
                  <li>Aitoff all-sky projection of the helix network</li>
                  <li>6-face skybox atlas (TOP, LEFT, FRONT, RIGHT, BACK, BOTTOM)</li>
                </ul>
              </li>
              <li>Write a JSON file:
                <code>stur_universe_skybox_full_atlas_v5_0.json</code>
              </li>
            </ul>
          </li>
        </ol>
        <p class="tiny">
          In JupyterLite you‚Äôll find the JSON file in the file browser and can download it.
        </p>
      </div>
      <div>
        <p><strong>Option B ‚Äì Run locally (desktop / laptop)</strong></p>
        <ol class="steps">
          <li>Install Python&nbsp;3 if needed.</li>
          <li>Install dependencies:
            <br><code>pip install numpy matplotlib</code>
          </li>
          <li>Save the code below as
            <code>stur_universe_skybox_full_atlas_v5_0.py</code>.
          </li>
          <li>From a terminal:
            <br><code>python stur_universe_skybox_full_atlas_v5_0.py</code>
          </li>
          <li>Three matplotlib windows will open:
            <ul>
              <li>3D skeleton view (STUR fog + helices + CMB arrow)</li>
              <li>Aitoff all-sky projection of helix paths</li>
              <li>Six-panel cube-map skybox (TOP, LEFT, FRONT, RIGHT, BACK, BOTTOM)</li>
            </ul>
          </li>
          <li>
            The JSON file will be written in the same directory.
            You can change the name by editing <code>JSON_FILENAME</code> near the top.
          </li>
        </ol>
      </div>
    </div>
  </section>

  <!-- PYTHON MONSTER CODE -->
  <section class="panel">
    <div class="panel-header">
      <div class="panel-title">STUR Universe Atlas ‚Äì Python Monster Code (v5.0)</div>
      <div class="panel-tag">3D Skeleton ¬∑ Aitoff ¬∑ 6-Face Skybox ¬∑ JSON Catalog</div>
    </div>

    <div class="code-shell">
      <div class="code-shell-header">
        <div class="code-shell-header-left">
          <span class="dot"></span><span class="dot"></span><span class="dot"></span>
          <span class="code-filename">stur_universe_skybox_full_atlas_v5_0.py</span>
        </div>
        <div class="code-actions">
          <button class="btn-inline" id="copyBtnTop">Copy</button>
          <button class="btn-inline" id="selectBtnTop">Select all</button>
        </div>
      </div>
      <textarea id="sturCode" spellcheck="false">
#!/usr/bin/env python3
# ======================================================================
# STUR UNIVERSE SKYBOX ‚Äì FULL ATLAS v5.0 (Earth POV, Pyodide-Safe)
# ======================================================================
# Sheldon L. Lindberg (2025)
#
# Features:
#   - Earth at origin, full 4œÄ sky
#   - 3D STUR coherence fog + helix funnels
#   - Aitoff all-sky projection of helix paths
#   - 6-face cube-map skybox (TOP, LEFT, FRONT, RIGHT, BACK, BOTTOM)
#   - Major clusters, walls, Local Group, voids/repellers, JWST fields,
#     synthetic 2MRS-like galaxies
#   - Earth-ray lines to major structures in 3D view
#   - CMB dipole arrow
#   - JSON catalog of:
#        * structure list
#        * helix paths + STUR profiles (subsampled)
#        * subsampled STUR fog
#        * citation block for underlying catalogs
#
# Pyodide / JupyterLite safety:
#   - NO giant JSON printed to stdout.
#   - JSON is written only to a file:
#       stur_universe_skybox_full_atlas_v5_0.json
#
# Dependencies: numpy, matplotlib, math, json
# ======================================================================

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  # register 3D projection
import math, json

plt.style.use("dark_background")

print("Start running STUR Universe Skybox v5.0 ......")

# ======================================================================
# CONFIG
# ======================================================================

CONFIG = {
    "label": "STUR_UNIVERSE_SKYBOX_FULL_ATLAS_v5_0_MAX_REALISM",

    # STUR fog sampling
    "N_FIELD_SAMPLES":   180000,  # total STUR fog samples
    "N_FIELD_SUB_PLOT":   90000,  # subset used for plotting
    "N_FIELD_SUB_JSON":    5000,  # subset stored in JSON

    # Helix resolution
    "N_STEPS_HELIX":        750,  # points per helix path
    "HELIX_TURNS_MAJOR":    4.0,
    "HELIX_TURNS_MINOR":    2.0,
    "HELIX_TURNS_JWST":     3.0,

    # Random seed
    "RANDOM_SEED":          42,

    # Fog mode and helix style (for future tweaks)
    "fog_mode":      "hybrid_S_weighted",
    "helix_style":   "scientific_halo"
}

JSON_FILENAME = "stur_universe_skybox_full_atlas_v5_0.json"

# ======================================================================
# STUR COHERENCE
# ======================================================================

def S_stur(r, L0):
    """
    STUR coherence:
        S(r) = tanh(x) * (1 - exp(-x)), x = r / L0

    Supports scalar or array r, L0 (broadcasted).
    """
    r  = np.asarray(r, dtype=float)
    L0 = np.asarray(L0, dtype=float)

    x = np.where(L0 > 0.0, r / L0, 0.0)
    x = np.clip(x, 0.0, 80.0)

    return np.tanh(x) * (1.0 - np.exp(-x))

# ======================================================================
# COSMOLOGY
# ======================================================================

deg2rad = math.pi / 180.0
rad2deg = 180.0 / math.pi

c_kms   = 299792.458
H0_kms  = 70.0
Omega_m = 0.3
Omega_L = 0.7

Z_MAX   = 20.0
N_ZGRID = 2000

def E_z(z):
    """Dimensionless H(z)/H0."""
    return math.sqrt(Omega_m * (1.0 + z)**3 + Omega_L)

z_grid = np.linspace(0.0, Z_MAX, N_ZGRID)
D_grid = np.zeros_like(z_grid)

for i in range(1, N_ZGRID):
    z0, z1 = z_grid[i-1], z_grid[i]
    dz = z1 - z0
    f0 = c_kms / (H0_kms * E_z(z0))
    f1 = c_kms / (H0_kms * E_z(z1))
    D_grid[i] = D_grid[i-1] + 0.5 * (f0 + f1) * dz

R_MAX_MPC = float(D_grid[-1])

def comoving_distance_Mpc(z):
    """z ‚Üí D_C(z) in Mpc, tabulated / interpolated."""
    if z <= 0.0:
        return 0.0
    if z >= Z_MAX:
        z = Z_MAX
    return float(np.interp(z, z_grid, D_grid))

def redshift_from_distance(r):
    """Approx inverse D_C ‚Üí z."""
    if r <= 0.0:
        return 0.0
    if r >= R_MAX_MPC:
        r = R_MAX_MPC
    return float(np.interp(r, D_grid, z_grid))

# ======================================================================
# COORDINATE HELPERS
# ======================================================================

def sph_to_cart(ra_deg, dec_deg, r):
    ra  = ra_deg  * deg2rad
    dec = dec_deg * deg2rad
    x = r * math.cos(dec) * math.cos(ra)
    y = r * math.cos(dec) * math.sin(ra)
    z = r * math.sin(dec)
    return np.array([x, y, z], dtype=float)

def cart_to_sph(vec):
    x, y, z = vec
    r = math.sqrt(x*x + y*y + z*z) + 1e-12
    dec = rad2deg * math.asin(z / r)
    ra  = rad2deg * math.atan2(y, x)
    return ra, dec, r

def hms(h, m, s):
    return h + m/60.0 + s/3600.0

def dms(sign, d, m, s):
    sgn = 1 if sign >= 0 else -1
    return sgn * (abs(d) + m/60.0 + s/3600.0)

# ======================================================================
# STRUCTURE CATALOG ‚Äì FULL ATLAS
# ======================================================================

def build_structure_catalog():
    """
    Build list of structures with fields:
      name, ra_deg, dec_deg, dist_Mpc, is_repeller,
      kind, catalog, importance
    """
    structures = []

    # ---- Local Group + satellites ------------------------------------
    local_group = [
        ("Milky Way Plane (ref)",   hms(17,45,0)*15, dms( 0,  0,  0, 0), 0.01),
        ("M31 Andromeda",           hms( 0,42,44.3)*15, 41.269,         0.78),
        ("M33 Triangulum",          hms( 1,33,50.9)*15, 30.660,         0.86),
        ("LMC",                     80.89,             -69.76,          0.05),
        ("SMC",                     13.19,             -72.83,          0.06),
        ("M81 Group",               148.9,              69.1,           3.60),
        ("Centaurus A Group",       201.4,             -43.0,           3.70),
        ("M101 Group",              210.8,              54.3,           7.00),
    ]
    for name, ra, dec, dist in local_group:
        structures.append({
            "name":        name,
            "ra_deg":      float(ra),
            "dec_deg":     float(dec),
            "dist_Mpc":    float(dist),
            "is_repeller": False,
            "kind":        "local_group",
            "catalog":     "LocalGroup",
            "importance":  "major",
        })

    # ---- Major clusters, walls, superclusters ------------------------
    clusters = [
        ("Virgo Cluster",
         hms(12,27,0)*15, dms(+1,12,43,0), 16.5, "cluster",      "NearbyClusters"),

        ("Fornax Cluster",
         54.65,          -35.45,           20.0, "cluster",      "NearbyClusters"),

        ("Hydra Cluster",
         159.0,          -27.6,            55.0, "cluster",      "NearbyClusters"),

        ("Centaurus Cluster",
         192.2,          -41.3,            45.0, "cluster",      "NearbyClusters"),

        ("Norma Cluster (Great Attractor)",
         hms(16,14,0)*15, dms(-1,60,52,0), 68.0, "cluster",      "GreatAttractor"),

        ("Ophiuchus Cluster",
         258.1,         -23.4,            120.0, "cluster",      "NearbyClusters"),

        ("Perseus Cluster",
         49.95,          41.51,            75.0, "cluster",      "NearbyClusters"),

        ("Coma Cluster (Abell 1656)",
         194.95,         27.98,           100.0, "cluster",      "Abell"),

        ("Shapley Core (A3558)",
         201.0,         -31.7,           200.0, "supercluster", "Shapley"),

        ("Perseus‚ÄìPisces Spine",
         40.0,           20.0,            70.0, "wall",         "PerseusPisces"),

        ("Sculptor Wall",
         0.0,           -30.0,            15.0, "wall",         "SculptorWall"),

        ("Centaurus Wall",
         190.0,         -30.0,            45.0, "wall",         "CentaurusWall"),

        ("Local Sheet (Laniakea)",
         150.0,         -10.0,             7.0, "supercluster", "Laniakea"),

        ("Laniakea Basin Core",
         160.0,         -45.0,            70.0, "supercluster", "Laniakea"),
    ]
    for name, ra, dec, dist, kind, cat in clusters:
        structures.append({
            "name":        name,
            "ra_deg":      float(ra),
            "dec_deg":     float(dec),
            "dist_Mpc":    float(dist),
            "is_repeller": False,
            "kind":        kind,
            "catalog":     cat,
            "importance":  "major",
        })

    # ---- Major voids / repellers & Local Void wall -------------------
    voids = [
        ("Dipole Repeller", 347.8,   7.1, 220.0, "void_repeller"),
        ("Local Void",      210.0,  15.0,  25.0, "void"),
        ("Local Void Wall", 190.0,   0.0,  35.0, "wall"),
        ("Bootes Void",     210.0,  50.0,  70.0, "void"),
        ("Eridanus Void",    70.0, -20.0,  80.0, "void"),
    ]
    for name, ra, dec, dist, vkind in voids:
        is_rep = (vkind == "void_repeller")
        kind   = "void" if vkind not in ("wall", "void_repeller") else \
                 ("wall" if vkind == "wall" else "void")
        structures.append({
            "name":        name,
            "ra_deg":      float(ra),
            "dec_deg":     float(dec),
            "dist_Mpc":    float(dist),
            "is_repeller": bool(is_rep),
            "kind":        kind,
            "catalog":     "VoidCatalog",
            "importance":  "major",
        })

    # ---- JWST deep fields --------------------------------------------
    jwst_fields = [
        ("CEERS (Extended Groth Strip)",
         hms(14,19,43)*15, dms(+1,52,53,0), 10.0),

        ("JADES (GOODS-South)",
         hms(3,32,38)*15,  dms(-1,27,47,0), 14.0),

        ("HUDF Field",
         hms(3,32,39)*15,  dms(-1,27,47,29), 12.0),

        ("SMACS 0723 Field",
         hms(7,23,16)*15,  dms(-1,73,27,0), 13.0),
    ]
    for name, ra, dec, zmax in jwst_fields:
        dist = comoving_distance_Mpc(zmax)
        structures.append({
            "name":        name,
            "ra_deg":      float(ra),
            "dec_deg":     float(dec),
            "dist_Mpc":    float(dist),
            "is_repeller": False,
            "kind":        "jwst",
            "catalog":     "JWST",
            "importance":  "major",
        })

    # ---- Mock 2MRS-like galaxy sample --------------------------------
    N_2MRS = 320
    np.random.seed(CONFIG["RANDOM_SEED"] + 7)
    ra2   = np.random.uniform(0.0, 360.0, N_2MRS)
    u_dec = np.random.uniform(-1.0, 1.0,   N_2MRS)
    dec2  = np.arcsin(u_dec) * rad2deg
    logd  = np.random.uniform(math.log10(5.0),
                              math.log10(250.0),
                              N_2MRS)
    dist2 = 10.0**logd

    for i in range(N_2MRS):
        structures.append({
            "name":        f"2MRS_GAL_{i+1:03d}",
            "ra_deg":      float(ra2[i]),
            "dec_deg":     float(dec2[i]),
            "dist_Mpc":    float(dist2[i]),
            "is_repeller": False,
            "kind":        "galaxy_2mrs",
            "catalog":     "2MRS_Mock",
            "importance":  "minor",
        })

    return structures

# Build catalog and attach Cartesian coords
structures = build_structure_catalog()
for s in structures:
    xyz = sph_to_cart(s["ra_deg"], s["dec_deg"], s["dist_Mpc"])
    s["xyz"] = [float(xyz[0]), float(xyz[1]), float(xyz[2])]

# Sources that contribute to STUR fog potential
field_sources = [s for s in structures
                 if s["kind"] in ("cluster", "supercluster", "void", "wall")]
field_xyz   = np.array([s["xyz"]      for s in field_sources])
field_dist  = np.array([s["dist_Mpc"] for s in field_sources])
field_rep   = np.array([s["is_repeller"] for s in field_sources], dtype=bool)

# ======================================================================
# STUR COSMIC FOG ‚Äì HYBRID MODE
# ======================================================================

np.random.seed(CONFIG["RANDOM_SEED"])
N_FIELD = CONFIG["N_FIELD_SAMPLES"]

# Isotropic in direction, ‚àù r^2 in radius (uniform in volume)
u_rand  = np.random.rand(N_FIELD)
r_samp  = R_MAX_MPC * np.cbrt(u_rand)
theta   = np.arccos(1.0 - 2.0*np.random.rand(N_FIELD))
phi     = 2.0 * np.pi * np.random.rand(N_FIELD)

x = r_samp * np.sin(theta) * np.cos(phi)
y = r_samp * np.sin(theta) * np.sin(phi)
z = r_samp * np.cos(theta)
field_pts = np.stack([x, y, z], axis=1)

if len(field_sources) > 0:
    diffs = field_pts[:, None, :] - field_xyz[None, :, :]   # (N, M, 3)
    dists = np.linalg.norm(diffs, axis=2) + 1e-6            # (N, M)

    signs = np.where(field_rep, -1.0, 1.0)[None, :]         # (1, M)
    L0s   = np.maximum(field_dist / 10.0, 1.0)[None, :]     # (1, M)

    S_each = S_stur(dists, L0s)
    Svals  = np.sum(signs * S_each / (dists**2), axis=1)
else:
    Svals = np.zeros(N_FIELD, dtype=float)

S_min, S_max = float(Svals.min()), float(Svals.max())
S_norm = (Svals - S_min) / (S_max - S_min + 1e-12)

z_field   = np.array([redshift_from_distance(r) for r in r_samp])
z_norm    = np.clip(z_field / Z_MAX, 0.0, 1.0)

# Spherical angles used for Aitoff
ra_field_deg  = rad2deg * np.arctan2(y, x)
ra_field_deg  = (ra_field_deg + 180.0) % 360.0 - 180.0
dec_field_deg = rad2deg * np.arcsin(
    z / (np.linalg.norm(field_pts, axis=1) + 1e-12)
)

# ======================================================================
# HELIX GENERATOR
# ======================================================================

def helix_turns_for_kind(kind, importance):
    if kind == "jwst":
        return CONFIG["HELIX_TURNS_JWST"]
    if importance == "major":
        return CONFIG["HELIX_TURNS_MAJOR"]
    return CONFIG["HELIX_TURNS_MINOR"]

def generate_central_helix(axis_vec, R_max, turns, n_steps, rep=False):
    """
    Generate a single central helix along axis_vec from r=0 to R_max.
    rep=True -> repeller-style radial envelope (opening).
    """
    axis = np.asarray(axis_vec, dtype=float)
    norm = np.linalg.norm(axis)
    if norm == 0.0:
        axis = np.array([1.0, 0.0, 0.0])
    else:
        axis /= norm

    # Build orthonormal basis: axis, e1, e2
    tmp = np.array([0.0, 0.0, 1.0])
    if abs(np.dot(axis, tmp)) > 0.9:
        tmp = np.array([1.0, 0.0, 0.0])
    e1 = np.cross(axis, tmp)
    e1 /= np.linalg.norm(e1)
    e2 = np.cross(axis, e1)

    s_vals = np.linspace(0.0, 1.0, n_steps)
    pts    = np.zeros((n_steps, 3), dtype=float)
    S_prof = np.zeros(n_steps, dtype=float)
    r_prof = np.zeros(n_steps, dtype=float)

    L0 = max(R_max / 10.0, 1.0)
    base_radius = 0.08 * R_max

    for i, s in enumerate(s_vals):
        # focus radius: smooth easing from 0 to R_max
        r_here = 0.5 * R_max * (1.0 - math.cos(math.pi * s))

        if rep:
            # repeller: let the outer region "open" more strongly
            rep_factor = 1.0 + 0.8 * (s**2)
            r_here *= rep_factor
            r_here = min(r_here, R_max)

        S_here = float(S_stur(r_here, L0))
        S_prof[i] = S_here
        r_prof[i] = r_here

        helix_r = base_radius * (0.2 + 0.8 * S_here)
        angle   = 2.0 * math.pi * turns * s

        pos = axis * r_here
        pos = pos + helix_r * (math.cos(angle)*e1 + math.sin(angle)*e2)
        pts[i, :] = pos

    return pts, S_prof, r_prof

# Build helix catalog for major structures (non-mock galaxies)
helix_catalog = {}
for s in structures:
    if s["kind"] == "galaxy_2mrs":
        continue  # do not build helices to every mock galaxy

    axis_vec = np.array(s["xyz"])
    R_max    = float(s["dist_Mpc"])
    turns    = helix_turns_for_kind(s["kind"], s["importance"])
    rep      = bool(s["is_repeller"])

    helix_pts, S_prof, r_prof = generate_central_helix(
        axis_vec, R_max, turns, CONFIG["N_STEPS_HELIX"], rep=rep
    )
    helix_catalog[s["name"]] = {
        "points": helix_pts,
        "S_prof": S_prof,
        "r_prof": r_prof,
        "is_repeller": rep,
    }

# ======================================================================
# CMB DIPOLE (VECTOR ONLY, DIRECTIONAL ARROW)
# ======================================================================

cmb_ra_deg  = 168.0
cmb_dec_deg = -7.0
cmb_vec = sph_to_cart(cmb_ra_deg, cmb_dec_deg, 1.0)
cmb_vec = cmb_vec / (np.linalg.norm(cmb_vec) + 1e-12)

# ======================================================================
# PLOTTING UTILITIES
# ======================================================================

def set_equal_aspect_3d(ax):
    limits = np.array([ax.get_xlim3d(),
                       ax.get_ylim3d(),
                       ax.get_zlim3d()])
    spans   = limits[:, 1] - limits[:, 0]
    centers = np.mean(limits, axis=1)
    radius  = 0.5 * max(spans)
    ax.set_xlim3d([centers[0]-radius, centers[0]+radius])
    ax.set_ylim3d([centers[1]-radius, centers[1]+radius])
    ax.set_zlim3d([centers[2]-radius, centers[2]+radius])

# ======================================================================
# 3D SKELETON VIEW
# ======================================================================

def plot_3d_skeleton():
    N_sub = min(CONFIG["N_FIELD_SUB_PLOT"], len(field_pts))
    idx   = np.linspace(0, len(field_pts)-1, N_sub, dtype=int)

    fig = plt.figure(figsize=(9, 9))
    ax  = fig.add_subplot(111, projection="3d")
    ax.set_title("STUR Universe Atlas ‚Äì 3D Skeleton (Earth POV)")

    # STUR fog
    colors = plt.cm.plasma(z_norm[idx])
    ax.scatter(field_pts[idx,0], field_pts[idx,1], field_pts[idx,2],
               c=colors, s=1.0, alpha=0.12, linewidths=0)

    # Earth at origin
    ax.scatter([0], [0], [0], color="white", s=40)
    ax.text(0, 0, 0, "Earth", color="white",
            ha="center", va="top", fontsize=8)

    # Earth rays to major clusters / superclusters
    for s in structures:
        if s["kind"] not in ("cluster", "supercluster", "void", "wall", "jwst"):
            continue
        xyz = np.array(s["xyz"])
        col = "orange" if s["kind"] in ("cluster","supercluster") else \
              ("cyan" if s["kind"] in ("void","wall") else "magenta")
        ax.plot([0, xyz[0]], [0, xyz[1]], [0, xyz[2]],
                color=col, alpha=0.35, linewidth=0.6)

    # Helix paths for non-mock structures
    for s in structures:
        if s["kind"] == "galaxy_2mrs":
            continue
        hc = helix_catalog.get(s["name"])
        if hc is None:
            continue
        pts = hc["points"]
        rep = hc["is_repeller"]
        if s["kind"] == "jwst":
            col = "magenta"
            lw  = 1.4
        elif rep:
            col = "cyan"
            lw  = 1.3
        elif s["kind"] in ("cluster","supercluster"):
            col = "orange"
            lw  = 1.7
        elif s["kind"] == "wall":
            col = "yellow"
            lw  = 1.1
        else:
            col = "white"
            lw  = 0.9

        ax.plot(pts[:,0], pts[:,1], pts[:,2],
                color=col, alpha=0.9, linewidth=lw)

    # CMB dipole arrow
    cmb_len = comoving_distance_Mpc(0.02)
    tip     = cmb_vec * cmb_len
    ax.quiver(0,0,0, tip[0], tip[1], tip[2],
              color="lime", linewidth=2.0, arrow_length_ratio=0.1)
    ax.text(tip[0], tip[1], tip[2],
            "CMB Dipole", color="lime", fontsize=8,
            ha="center", va="bottom")

    ax.set_xlabel("x (Mpc)")
    ax.set_ylabel("y (Mpc)")
    ax.set_zlabel("z (Mpc)")

    set_equal_aspect_3d(ax)
    plt.tight_layout()

    try:
        fig.savefig("STUR_Universe_3D_Skeleton_v5_0.png",
                    dpi=300, bbox_inches="tight")
    except Exception:
        pass

# ======================================================================
# AITOFF ALL-SKY PROJECTION
# ======================================================================

def plot_aitoff():
    fig = plt.figure(figsize=(10, 6))
    ax  = fig.add_subplot(111, projection="aitoff")
    ax.set_title("STUR Universe Atlas ‚Äì Aitoff Projection (Helix Network)")

    # Fog (subsample)
    N_sub = min(CONFIG["N_FIELD_SUB_PLOT"], len(field_pts))
    idx   = np.linspace(0, len(field_pts)-1, N_sub, dtype=int)
    ra_rad  = np.radians(ra_field_deg[idx])
    dec_rad = np.radians(dec_field_deg[idx])
    ax.scatter(ra_rad, dec_rad, s=1.0, alpha=0.10, c="0.5")

    # Helper to project helix path
    def proj_helix(pts, **kwargs):
        raL, decL = [], []
        for p in pts:
            ra_deg, dec_deg, r = cart_to_sph(p)
            ra_wrap = (ra_deg + 180.0) % 360.0 - 180.0
            raL.append(math.radians(ra_wrap))
            decL.append(math.radians(dec_deg))
        ax.plot(raL, decL, **kwargs)

    for s in structures:
        if s["kind"] == "galaxy_2mrs":
            continue
        hc = helix_catalog.get(s["name"])
        if hc is None:
            continue
        col = "magenta" if s["kind"] == "jwst" else \
              ("cyan" if s["is_repeller"] else
               ("orange" if s["kind"] in ("cluster","supercluster") else
                ("yellow" if s["kind"] == "wall" else "white")))
        lw  = 1.7 if s["kind"] in ("cluster","supercluster") else 1.1
        proj_helix(hc["points"], color=col, alpha=0.9, linewidth=lw)

    ax.grid(True)
    plt.tight_layout()

    try:
        fig.savefig("STUR_Universe_Aitoff_v5_0.png",
                    dpi=300, bbox_inches="tight")
    except Exception:
        pass

# ======================================================================
# 6-FACE CUBE-MAP SKYBOX
# ======================================================================

FACE_NAMES = ["RIGHT(+X)", "LEFT(-X)", "TOP(+Y)", "BOTTOM(-Y)", "FRONT(+Z)", "BACK(-Z)"]

def direction_to_cube_face(x, y, z):
    """
    Assign 3D direction to skybox face and (u,v) in [-1,1]x[-1,1].
    Simple cube-map projection.
    """
    ax = abs(x); ay = abs(y); az = abs(z)

    if ax >= ay and ax >= az:
        # ¬±X
        if x >= 0:
            face = 0  # +X = RIGHT
            u = -z / ax
            v =  y / ax
        else:
            face = 1  # -X = LEFT
            u =  z / ax
            v =  y / ax

    elif ay >= ax and ay >= az:
        # ¬±Y
        if y >= 0:
            face = 2  # +Y = TOP
            u =  x / ay
            v =  z / ay
        else:
            face = 3  # -Y = BOTTOM
            u =  x / ay
            v = -z / ay

    else:
        # ¬±Z
        if z >= 0:
            face = 4  # +Z = FRONT
            u =  x / az
            v =  y / az
        else:
            face = 5  # -Z = BACK
            u = -x / az
            v =  y / az

    return face, float(u), float(v)

def plot_skybox():
    fig, axes = plt.subplots(2, 3, figsize=(11, 7))
    fig.suptitle("STUR Universe Atlas ‚Äì 6-Face Skybox (Earth POV)", y=0.98)

    # Prepare containers for each face
    face_pts_u = [[] for _ in range(6)]
    face_pts_v = [[] for _ in range(6)]
    face_pts_c = [[] for _ in range(6)]

    # STUR fog (subsample)
    N_sub = min(CONFIG["N_FIELD_SUB_PLOT"], len(field_pts))
    idx   = np.linspace(0, len(field_pts)-1, N_sub, dtype=int)

    for i in idx:
        px, py, pz = field_pts[i]
        r_norm = math.sqrt(px*px + py*py + pz*pz) + 1e-12
        nx, ny, nz = px/r_norm, py/r_norm, pz/r_norm
        face, u, v = direction_to_cube_face(nx, ny, nz)
        if u*u + v*v <= 1.0:
            face_pts_u[face].append(u)
            face_pts_v[face].append(v)
            face_pts_c[face].append(z_norm[i])

    # Plot fog
    for fi in range(6):
        ax = axes[fi//3, fi%3]
        ax.set_aspect("equal")
        ax.set_xlim(-1, 1)
        ax.set_ylim(-1, 1)
        ax.set_xticks([])
        ax.set_yticks([])
        ax.set_title(FACE_NAMES[fi], fontsize=9)

        if face_pts_u[fi]:
            u_arr = np.array(face_pts_u[fi])
            v_arr = np.array(face_pts_v[fi])
            c_arr = np.array(face_pts_c[fi])
            ax.scatter(u_arr, v_arr, s=2.0,
                       c=plt.cm.plasma(c_arr),
                       alpha=0.18, linewidths=0)

        # circular FOV boundary
        circle = plt.Circle((0,0), 1.0,
                            edgecolor="0.4",
                            facecolor="none",
                            linewidth=0.5,
                            alpha=0.6)
        ax.add_patch(circle)

    # Overlay helix centers on each panel
    for s in structures:
        if s["kind"] == "galaxy_2mrs":
            continue
        hc = helix_catalog.get(s["name"])
        if hc is None:
            continue

        pts = hc["points"]
        col = "magenta" if s["kind"] == "jwst" else \
              ("cyan" if s["is_repeller"] else
               ("orange" if s["kind"] in ("cluster","supercluster") else
                ("yellow" if s["kind"] == "wall" else "white")))

        # Project each helix point into skybox
        for p in pts[::max(1, len(pts)//150)]:
            px, py, pz = p
            r_norm = math.sqrt(px*px + py*py + pz*pz) + 1e-12
            nx, ny, nz = px/r_norm, py/r_norm, pz/r_norm
            face, u, v = direction_to_cube_face(nx, ny, nz)
            if u*u + v*v <= 1.0:
                ax = axes[face//3, face%3]
                ax.scatter([u], [v], s=4.0,
                           color=col, alpha=0.9, linewidths=0)

    plt.tight_layout(rect=[0,0,1,0.96])

    try:
        fig.savefig("STUR_Universe_Skybox_6Face_v5_0.png",
                    dpi=300, bbox_inches="tight")
    except Exception:
        pass

# ======================================================================
# JSON OUTPUT (NO GIANT STDOUT PRINT)
# ======================================================================

def vec_to_list(v):
    return [float(v[0]), float(v[1]), float(v[2])]

def build_json_catalog():
    # Structures (lightweight)
    structures_json = []
    for s in structures:
        entry = {
            "name":        s["name"],
            "ra_deg":      float(s["ra_deg"]),
            "dec_deg":     float(s["dec_deg"]),
            "dist_Mpc":    float(s["dist_Mpc"]),
            "is_repeller": bool(s["is_repeller"]),
            "kind":        s["kind"],
            "catalog":     s["catalog"],
            "importance":  s["importance"],
            "xyz_Mpc":     list(s["xyz"]),
        }
        structures_json.append(entry)

    # Helices (subsample along each path)
    helices_json = {}
    for s in structures:
        if s["kind"] == "galaxy_2mrs":
            continue
        hc = helix_catalog.get(s["name"])
        if hc is None:
            continue

        pts   = hc["points"]
        Sprof = hc["S_prof"]
        rprof = hc["r_prof"]

        n = len(pts)
        step = max(1, n // 120)  # keep up to ~120 points in JSON
        idx  = np.arange(0, n, step, dtype=int)

        helices_json[s["name"]] = {
            "is_repeller": bool(s["is_repeller"]),
            "kind":        s["kind"],
            "N_points":    int(len(idx)),
            "r_Mpc":       [float(rprof[i]) for i in idx],
            "S_of_r":      [float(Sprof[i]) for i in idx],
            "xyz_Mpc":     [vec_to_list(pts[i]) for i in idx],
        }

    # STUR fog subsample
    N_json = min(CONFIG["N_FIELD_SUB_JSON"], len(field_pts))
    idx    = np.linspace(0, len(field_pts)-1, N_json, dtype=int)

    fog_json = {
        "N_total":  int(len(field_pts)),
        "N_in_JSON": int(N_json),
        "xyz_Mpc":  [vec_to_list(field_pts[i]) for i in idx],
        "r_Mpc":    [float(r_samp[i]) for i in idx],
        "redshift": [float(z_field[i]) for i in idx],
        "S_value_norm": [float(S_norm[i]) for i in idx],
    }

    # Citation block (human-readable references)
    citations = [
        "Local Group geometry: generic review of Local Group structure.",
        "Nearby clusters & walls: based on qualitative positions of Virgo, "
        "Fornax, Hydra, Centaurus, Great Attractor, Shapley, Perseus‚ÄìPisces, "
        "Sculptor, Centaurus Wall, and Laniakea basin.",
        "Void and repeller picture: inspired by cosmic flow reconstructions "
        "(e.g. Tully et al., 'The Local Velocity Anomaly', 'The Laniakea "
        "supercluster of galaxies').",
        "2MRS-like mock galaxies: schematic stand-in for a shallow redshift "
        "survey around z ~ 0.03‚Äì0.05.",
        "JWST deep fields: CEERS, JADES, HUDF, SMACS 0723 pointing positions "
        "and redshift depths are approximate and used illustratively.",
    ]

    json_catalog = {
        "model": CONFIG["label"],
        "note": (
            "Earth-POV STUR universe atlas with 3D skeleton, Aitoff, and 6-face "
            "skybox. This is a pedagogical / conceptual map, not a complete "
            "survey catalog."
        ),
        "cosmology": {
            "H0_km_s_Mpc": float(H0_kms),
            "Omega_m":     float(Omega_m),
            "Omega_Lambda": float(Omega_L),
            "Z_max":       float(Z_MAX),
            "R_max_Mpc":   float(R_MAX_MPC),
        },
        "structures": structures_json,
        "helices":    helices_json,
        "stur_fog_subsample": fog_json,
        "citations":  citations,
    }

    return json_catalog

# ======================================================================
# MAIN EXECUTION
# ======================================================================

def main():
    plot_3d_skeleton()
    plot_aitoff()
    plot_skybox()

    catalog = build_json_catalog()
    try:
        with open(JSON_FILENAME, "w", encoding="utf-8") as f:
            json.dump(catalog, f, indent=2)
        print(f"JSON atlas written to: {JSON_FILENAME}")
    except Exception as e:
        print("Warning: could not write JSON file:", e)

if __name__ == "__main__":
    main()
      </textarea>
    </div>

    <div class="button-row">
      <button class="btn primary" id="copyBtnMain">üìã Copy STUR Universe Atlas Code</button>
      <button class="btn" id="selectBtnMain">üîé Select all code</button>

      <!-- JupyterLite demo (works immediately) -->
      <a class="btn accent"
         href="https://jupyterlite.github.io/demo/lab/index.html"
         target="_blank" rel="noopener">
        ‚ñ∂ Open JupyterLite
      </a>

      <a class="btn" href="../index.html">üè† Back to STUR Physics Lab</a>
    </div>

    <div class="footer-nav">
      <div class="left">
        <span class="chip">Author: Sheldon L. Lindberg (2025)</span>
        <span class="chip">STUR Universe Atlas v5.0</span>
      </div>
      <div class="right">
        <span class="tiny">
          This atlas is a STUR learning tool. You can always upgrade the structure
          list, cosmology, or helix rules and keep the same HTML shell.
        </span>
      </div>
    </div>
  </section>

  <!-- INTERPRETING THE PLOTS -->
  <section class="panel alt">
    <div class="panel-header">
      <div class="panel-title">How to read the three views</div>
      <div class="panel-tag">Skeleton ¬∑ All-Sky ¬∑ Skybox</div>
    </div>
    <div class="grid-two">
      <div>
        <p><strong>3D Skeleton (Earth inside the helix web)</strong></p>
        <ul>
          <li>
            The colored fog points are STUR-weighted samples of the cosmic
            field, with color tied to approximate redshift.
          </li>
          <li>
            Bright helical curves show focused flows toward attractors
            (clusters, walls, Laniakea) or opening funnels away from repellers
            and voids.
          </li>
          <li>
            Thin rays from Earth to major structures mark the backbone of the
            local flow field.
          </li>
          <li>
            The lime arrow shows the <strong>CMB dipole</strong> direction.
          </li>
        </ul>
      </div>
      <div>
        <p><strong>Aitoff + 6-Face Skybox</strong></p>
        <ul>
          <li>
            The <strong>Aitoff projection</strong> gives a standard RA/Dec
            sky view: fog as a grey background, colored helix paths drawn
            across the celestial sphere.
          </li>
          <li>
            The <strong>six skybox panels</strong> (RIGHT, LEFT, TOP, BOTTOM,
            FRONT, BACK) tile the full 4œÄ sky around Earth. Each panel shows
            STUR fog and helix footprints inside a circular field of view.
          </li>
          <li>
            In game / VR language, this is a <strong>STUR-ready cube map</strong>
            you could use as a texture on a sky dome or environment probe.
          </li>
        </ul>
        <p class="tiny">
          In the STUR story, this page is the <strong>Universe Module atlas</strong>:
          the other labs (helix ladder, quark/Earth/DNA labs, etc.) plug into it.
        </p>
      </div>
    </div>
  </section>

</main>

<button class="scroll-top" id="scrollTopBtn">‚Üë Top</button>

<script>
  (function () {
    const codeElem = document.getElementById("sturCode");
    const copyButtons = [
      document.getElementById("copyBtnTop"),
      document.getElementById("copyBtnMain")
    ].filter(Boolean);
    const selectButtons = [
      document.getElementById("selectBtnTop"),
      document.getElementById("selectBtnMain")
    ].filter(Boolean);

    function selectAll() {
      codeElem.focus();
      codeElem.select();
    }

    function copyCode() {
      selectAll();
      try {
        const ok = document.execCommand("copy");
        if (ok) {
          copyButtons.forEach(btn => btn.textContent = "‚úî Copied!");
          setTimeout(() => {
            copyButtons.forEach(btn => {
              if (btn.id === "copyBtnMain") {
                btn.textContent = "üìã Copy STUR Universe Atlas Code";
              } else {
                btn.textContent = "Copy";
              }
            });
          }, 1600);
        }
      } catch (e) {
        console.error(e);
      }
    }

    copyButtons.forEach(btn => btn.addEventListener("click", copyCode));
    selectButtons.forEach(btn => btn.addEventListener("click", selectAll));

    const scrollBtn = document.getElementById("scrollTopBtn");
    window.addEventListener("scroll", () => {
      if (window.scrollY > 320) {
        scrollBtn.classList.add("show");
      } else {
        scrollBtn.classList.remove("show");
      }
    });
    scrollBtn.addEventListener("click", () => {
      window.scrollTo({ top: 0, behavior: "smooth" });
    });
  })();
</script>

</body>
</html>
