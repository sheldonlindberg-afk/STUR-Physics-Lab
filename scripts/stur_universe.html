<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>STUR Universe Atlas ‚Äì Full Skybox & Helical Cosmic Map (v1.0)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
  :root {
    --bg-main: #02030a;
    --bg-panel: #050814;
    --bg-panel-alt: #080c1f;
    --accent: #ffb347;
    --accent-2: #00d4ff;
    --accent-soft: rgba(0,212,255,0.25);
    --text-main: #e6edf3;
    --text-muted: #9caecb;
    --border-soft: #1b2538;
    --code-bg: #050711;
  }

  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    background:
      radial-gradient(circle at 12% 15%, #111936 0, #02030a 40%),
      radial-gradient(circle at 80% 80%, #00111f 0, #02030a 55%);
    color: var(--text-main);
    line-height: 1.6;
  }

  a {
    color: var(--accent-2);
    text-decoration: none;
  }
  a:hover {
    text-decoration: underline;
  }

  header {
    padding: 32px 16px 8px;
    text-align: center;
  }

  .logo-row {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    margin-bottom: 4px;
  }
  .logo-mark {
    width: 40px;
    height: 40px;
    border-radius: 999px;
    border: 1px solid var(--accent-soft);
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    letter-spacing: 0.12em;
    font-size: 11px;
    text-transform: uppercase;
    background: radial-gradient(circle at 30% 20%, #1e2847, #050814);
    box-shadow: 0 0 18px rgba(0,212,255,0.35);
  }
  .logo-text {
    font-size: 13px;
    text-transform: uppercase;
    letter-spacing: 0.24em;
    color: var(--text-muted);
  }

  h1 {
    margin: 6px 0;
    font-size: clamp(1.7rem, 4vw, 2.3rem);
  }
  .tagline {
    margin-top: 4px;
    color: var(--text-muted);
    font-size: 0.95rem;
  }
  .badge-row {
    margin-top: 10px;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 6px;
  }
  .badge {
    font-size: 0.72rem;
    text-transform: uppercase;
    letter-spacing: 0.14em;
    padding: 3px 8px;
    border-radius: 999px;
    border: 1px solid var(--border-soft);
    background: rgba(5,10,28,0.85);
    color: var(--text-muted);
  }
  .badge.accent {
    border-color: var(--accent-2);
    color: var(--accent-2);
    background: rgba(0,212,255,0.08);
  }

  main {
    max-width: 1080px;
    margin: 0 auto 40px;
    padding: 0 16px 40px;
  }

  .panel {
    background: radial-gradient(circle at 15% 0, #10182f, #050814);
    border-radius: 14px;
    border: 1px solid var(--border-soft);
    padding: 18px 18px 16px;
    margin-bottom: 16px;
    box-shadow: 0 0 30px rgba(0,0,0,0.6);
  }
  .panel.alt {
    background: radial-gradient(circle at 80% 10%, #07142d, #050814);
  }
  .panel-header {
    display: flex;
    align-items: baseline;
    justify-content: space-between;
    gap: 8px;
    margin-bottom: 4px;
  }
  .panel-title {
    font-size: 1rem;
    font-weight: 600;
  }
  .panel-tag {
    font-size: 0.75rem;
    color: var(--text-muted);
  }

  .grid-two {
    display: grid;
    grid-template-columns: minmax(0,2fr) minmax(0,2fr);
    gap: 14px;
  }
  @media (max-width: 800px) {
    .grid-two {
      grid-template-columns: minmax(0,1fr);
    }
  }

  ul {
    padding-left: 18px;
    margin-top: 6px;
    margin-bottom: 6px;
  }
  li {
    margin-bottom: 3px;
  }

  code {
    font-family: "JetBrains Mono", "SF Mono", Menlo, Monaco, Consolas, "Courier New", monospace;
    font-size: 0.85rem;
  }

  .inline-math {
    font-family: "Latin Modern Math", "STIX Two Math", "Times New Roman", serif;
    font-style: italic;
  }

  .equation-block {
    margin: 8px 0;
    padding: 8px 10px;
    border-radius: 10px;
    background: rgba(4,9,24,0.95);
    border: 1px solid rgba(255,255,255,0.04);
    font-family: "Latin Modern Math", "STIX Two Math", "Times New Roman", serif;
    font-size: 0.92rem;
  }

  .steps {
    list-style: decimal;
    padding-left: 20px;
    margin-top: 6px;
  }
  .steps li {
    margin-bottom: 5px;
  }

  .code-shell {
    margin-top: 4px;
    background: radial-gradient(circle at 0 0, #202744, #050711);
    border-radius: 14px;
    border: 1px solid #262f4d;
    overflow: hidden;
  }
  .code-shell-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 10px;
    border-bottom: 1px solid #262f4d;
    font-size: 0.78rem;
    color: var(--text-muted);
  }
  .code-shell-header-left {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .dot {
    width: 9px;
    height: 9px;
    border-radius: 50%;
    background: #ff5f57;
  }
  .dot:nth-child(2) { background: #febc2e; }
  .dot:nth-child(3) { background: #28c840; }
  .code-filename {
    color: #9fb4ff;
    font-family: "JetBrains Mono", monospace;
  }

  .code-actions {
    display: flex;
    gap: 8px;
  }

  textarea#sturCode {
    width: 100%;
    border: none;
    padding: 10px 12px 12px;
    margin: 0;
    resize: vertical;
    min-height: 520px;
    max-height: 1100px;
    color: #e8f0ff;
    background: var(--code-bg);
    font-family: "JetBrains Mono", monospace;
    font-size: 0.78rem;
    line-height: 1.4;
    tab-size: 4;
    overflow: auto;
    outline: none;
    white-space: pre;
  }

  .button-row {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 10px;
  }
  .btn {
    border-radius: 999px;
    border: 1px solid var(--border-soft);
    padding: 8px 14px;
    font-size: 0.85rem;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 6px;
    background: rgba(5,8,20,0.9);
    color: var(--text-main);
    text-decoration: none;
    white-space: nowrap;
  }
  .btn.primary {
    border-color: var(--accent-2);
    background: radial-gradient(circle at 0 0, #0c2334, #050814);
    box-shadow: 0 0 16px rgba(0,212,255,0.35);
  }
  .btn.accent {
    border-color: var(--accent);
    background: radial-gradient(circle at 0 0, #24160a, #050814);
  }
  .btn:hover {
    transform: translateY(-0.5px);
    box-shadow: 0 0 12px rgba(0,0,0,0.6);
  }

  .footer-nav {
    margin-top: 16px;
    padding-top: 10px;
    border-top: 1px solid var(--border-soft);
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    justify-content: space-between;
    align-items: center;
    font-size: 0.8rem;
    color: var(--text-muted);
  }
  .footer-nav .left,
  .footer-nav .right {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
  }

  .chip {
    border-radius: 999px;
    border: 1px solid var(--border-soft);
    padding: 3px 8px;
    font-size: 0.75rem;
    background: rgba(3,7,18,0.9);
  }

  .tiny {
    font-size: 0.75rem;
    color: var(--text-muted);
  }

  .highlight-pill {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    border-radius: 999px;
    padding: 4px 10px;
    border: 1px solid rgba(0,212,255,0.35);
    background: rgba(0,212,255,0.06);
    font-size: 0.78rem;
    color: var(--accent-2);
  }

  .scroll-top {
    position: fixed;
    right: 14px;
    bottom: 14px;
    border-radius: 999px;
    border: 1px solid rgba(0,212,255,0.35);
    background: rgba(3,7,18,0.95);
    padding: 6px 9px;
    font-size: 0.78rem;
    cursor: pointer;
    display: none;
    z-index: 50;
  }
  .scroll-top.show {
    display: inline-flex;
  }
</style>
</head>

<body>
<header id="top">
  <div class="logo-row">
    <div class="logo-mark">STUR</div>
    <div class="logo-text">Physics Lab</div>
  </div>
  <h1>STUR Universe Atlas ‚Äì Full Skybox & Helical Cosmic Map (v1.0)</h1>
  <div class="tagline">
    From Earth‚Äôs point of view to the cosmic web: real coordinates, helical funnels,
    and a STUR coherence field stitched into a 3D map and full-sky atlas.
  </div>
  <div class="badge-row">
    <span class="badge accent">Copy-and-Run Python Atlas</span>
    <span class="badge">Earth POV ¬∑ RA/Dec ¬∑ Redshift Shells</span>
    <span class="badge">JWST Deep Fields + Virgo / GA / Shapley / Repeller</span>
    <span class="badge">JSON Universe Atlas Summary</span>
  </div>
</header>

<main>

  <!-- OVERVIEW + PHYSICS STORY -->
  <section class="panel">
    <div class="panel-header">
      <div class="panel-title">What this STUR Universe Atlas does</div>
      <div class="panel-tag">Perspective: you are sitting at Earth inside the funnels</div>
    </div>
    <div class="grid-two">
      <div>
        <p>
          This is a <strong>single monster script</strong> that builds a
          <em>first-pass Universe Atlas</em> in the STUR framework. It combines:
        </p>
        <ul>
          <li>
            A simple flat ŒõCDM background to convert
            <span class="inline-math">z \leftrightarrow r_{\rm comoving}</span>.
          </li>
          <li>
            A <strong>STUR coherence field</strong>
            <div class="equation-block">
              \( S(r) = \tanh\!\big(x\big)\,\big(1 - e^{-x}\big), \quad x = \dfrac{r}{L_0} \)
            </div>
          </li>
          <li>
            Real-sky anchors:
            Virgo, Norma / Great Attractor, Shapley, and a Dipole Repeller.
          </li>
          <li>
            Real JWST deep-field pointings: CEERS, JADES, HUDF, SMACS 0723.
          </li>
        </ul>
        <p>
          From these ingredients, the code constructs:
        </p>
        <ul>
          <li>A 3D STUR field with helical funnels from Earth to each anchor.</li>
          <li>
            A full-sky <strong>Aitoff map</strong> in RA/Dec with projected helices.
          </li>
          <li>
            A <strong>4-panel skybox</strong> splitting the sky into four RA sectors:
            you can see how the funnels and JWST fields tile the sky.
          </li>
          <li>
            A diagnostic plot of <span class="inline-math">S(r)</span>
            for each anchor along its radial line.
          </li>
        </ul>
      </div>
      <div>
        <p><strong>STUR interpretation</strong></p>
        <p>
          In the STUR picture, all long-range structure is modulated by a coherence
          factor that multiplies the usual forces:
        </p>
        <div class="equation-block">
          \( \vec{F}_{\rm STUR}(\vec{r}) = S(r)\,\Big[
          \vec{F}_{\rm grav} + \vec{F}_{\rm EM} + \vec{F}_{\rm strong} + \vec{F}_{\rm spin}
          \Big] \)
        </div>
        <p>
          Here we don‚Äôt try to simulate full N-body gravity. Instead, we:
        </p>
        <ul>
          <li>Sample a 3D cloud of points in comoving distance.</li>
          <li>Compute a <strong>signed STUR field</strong> from the anchors
              (attractors vs. repeller).</li>
          <li>Use that as an ‚Äúenergy fog‚Äù color field in both 3D and sky maps.</li>
        </ul>
        <p class="tiny">
          All major ingredients ‚Äì cosmology, anchors, JWST pointings, helices,
          and selected STUR field samples ‚Äì are exported into a <strong>JSON atlas</strong>
          at the end so other scripts (or AI) can reuse the same universe skeleton.
        </p>
      </div>
    </div>
  </section>

  <!-- HOW TO RUN -->
  <section class="panel alt">
    <div class="panel-header">
      <div class="panel-title">How to run the STUR Universe Atlas</div>
      <div class="panel-tag">JupyterLite ¬∑ Pyodide ¬∑ Desktop Python 3</div>
    </div>
    <div class="grid-two">
      <div>
        <p><strong>Option A ‚Äì Run in a browser (JupyterLite / Pyodide)</strong></p>
        <ol class="steps">
          <li>Click the <strong>‚ÄúRun in JupyterLite‚Äù</strong> button below (opens in a new tab).</li>
          <li>In JupyterLite, create a new <strong>Python 3 notebook</strong>.</li>
          <li>
            Return to this page, click <strong>‚Äúüìã Copy STUR Universe Atlas Code‚Äù</strong>,
            and paste the code into a single notebook cell.
          </li>
          <li>Run the cell:
            <ul>
              <li>Figure 1: 3D STUR helical universe with redshift shells.</li>
              <li>Figure 2: Aitoff all-sky projection of field + helices.</li>
              <li>Figure 3: 4-panel skybox (RA sectors) from Earth POV.</li>
              <li>Figure 4: STUR coherence <span class="inline-math">S(r)</span> vs. radius for each anchor.</li>
              <li>Then a <strong>JSON atlas</strong> prints to the console.</li>
            </ul>
          </li>
        </ol>
        <p class="tiny">
          JupyterLite may or may not allow saving PNGs; the script wraps all
          <code>savefig</code> calls in <code>try/except</code> so it remains safe.
        </p>
      </div>
      <div>
        <p><strong>Option B ‚Äì Run locally (desktop / laptop)</strong></p>
        <ol class="steps">
          <li>Install dependencies:
            <br><code>pip install numpy matplotlib</code>
          </li>
          <li>Save the code as
            <code>stur_universe_atlas_v1.py</code>.
          </li>
          <li>From a terminal:
            <br><code>python stur_universe_atlas_v1.py</code>
          </li>
          <li>Four matplotlib windows will pop up with the figures.</li>
          <li>
            The JSON atlas will be printed to stdout; you can redirect it:
            <br><code>python stur_universe_atlas_v1.py &gt; stur_universe_atlas_v1.json</code>
          </li>
        </ol>
        <p class="tiny">
          If the script feels heavy, lower <code>N_FIELD_SAMPLES</code> or
          <code>N_STREAM</code> in the parameters section and rerun.
        </p>
      </div>
    </div>
  </section>

  <!-- PYTHON CODE BOX -->
  <section class="panel">
    <div class="panel-header">
      <div class="panel-title">Full STUR Universe Atlas Python code (v1.0)</div>
      <div class="panel-tag">3D map ¬∑ Aitoff sky ¬∑ 4-panel skybox ¬∑ JSON atlas</div>
    </div>

    <div class="code-shell">
      <div class="code-shell-header">
        <div class="code-shell-header-left">
          <span class="dot"></span><span class="dot"></span><span class="dot"></span>
          <span class="code-filename">stur_universe_atlas_v1.py</span>
        </div>
        <div class="code-actions">
          <button class="btn-inline" id="copyBtnTop">Copy</button>
          <button class="btn-inline" id="selectBtnTop">Select all</button>
        </div>
      </div>
      <textarea id="sturCode" spellcheck="false">
#!/usr/bin/env python3
# ===============================================================
# STUR Universe Atlas ‚Äì Full Skybox & Helical Cosmic Map (v1.0)
# ===============================================================
# Sheldon L. Lindberg (2025)
#
# This "monster" script builds a universe atlas from Earth's POV.
# It is meant as a conceptual + visual model in the STUR framework:
#
#  * Flat ŒõCDM background to map z <-> comoving distance (Mpc)
#  * STUR coherence factor:
#       S(r) = tanh(x)*(1 - exp(-x)),  x = r/L0
#  * Real-ish coordinates for:
#       - Virgo Cluster
#       - Norma / Great Attractor
#       - Shapley Supercluster
#       - Dipole Repeller (effective under-density)
#       - JWST deep fields: CEERS, JADES, HUDF, SMACS 0723
#  * Random 3D STUR field samples (comoving ball)
#  * Helical funnels from Earth to each anchor / JWST field
#
# The script produces four main figures:
#   1) 3D STUR helical universe + redshift shells + CMB dipole
#   2) All-sky Aitoff projection of STUR samples + central helices
#   3) 4-panel RA skybox (Earth POV, RA sectors)
#   4) S(r) vs r for each anchor along its line of sight
#
# Finally, it prints a JSON "atlas" with:
#   * Cosmology / configuration
#   * Anchor and JWST metadata
#   * Subsampled central helices
#   * Subsampled STUR field points
#
# Designed to be:
#   * 100% self-contained
#   * JupyterLite / Pyodide compatible (NumPy + matplotlib + json + math)
#   * Configurable at the top
# ===============================================================

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  # registers 3D projection
import json, math

plt.style.use("dark_background")

# ---------------------- GLOBAL SWITCHES ------------------------
# These can be tuned for performance vs. resolution.
Z_MAX              = 20.0     # Maximum redshift we consider
N_ZGRID            = 2000     # Integration grid for z->r
N_STREAM           = 60       # Helical strands per funnel
N_STEPS_HELIX      = 240      # Points along each strand
N_FIELD_SAMPLES    = 45000    # STUR 3D field samples
N_FIELD_SUB_JSON   = 4000     # How many field points to keep in JSON
N_HELIX_SUB_JSON   = 80       # Points per central helix for JSON export

# Random seed for reproducibility
np.random.seed(42)

# ---------------------- BASIC CONSTANTS ------------------------
deg2rad = math.pi / 180.0
rad2deg = 180.0 / math.pi

c_kms   = 299792.458    # km/s
H0_kms  = 70.0          # km/s/Mpc
Omega_m = 0.3
Omega_L = 0.7

# ---------------------- COSMOLOGY: z <-> r ---------------------
def E_z(z):
    """
    Dimensionless H(z)/H0 for flat ŒõCDM-like background:
        E(z) = sqrt( Œ©_m (1+z)^3 + Œ©_Œõ )
    """
    return math.sqrt(Omega_m*(1+z)**3 + Omega_L)

# Precompute comoving distance grid with simple trapezoid rule.
z_grid = np.linspace(0.0, Z_MAX, N_ZGRID)
D_grid = np.zeros_like(z_grid)

for i in range(1, N_ZGRID):
    z0, z1 = z_grid[i-1], z_grid[i]
    dz = z1 - z0
    f0 = c_kms / (H0_kms * E_z(z0))
    f1 = c_kms / (H0_kms * E_z(z1))
    D_grid[i] = D_grid[i-1] + 0.5*(f0 + f1)*dz

R_MAX_MPC = float(D_grid[-1])

def comoving_distance_Mpc(z):
    """Return comoving distance (Mpc) for redshift z using interpolation."""
    if z <= 0.0:
        return 0.0
    if z >= Z_MAX:
        z = Z_MAX
    return float(np.interp(z, z_grid, D_grid))

def redshift_from_distance(r_Mpc):
    """Inverse of comoving_distance_Mpc via interpolation."""
    if r_Mpc <= 0.0:
        return 0.0
    if r_Mpc >= R_MAX_MPC:
        r_Mpc = R_MAX_MPC
    return float(np.interp(r_Mpc, D_grid, z_grid))

# ---------------------- COORDINATES ----------------------------
def sph_to_cart(ra_deg, dec_deg, r):
    """
    Input RA,Dec in degrees and radius r.
    Returns numpy array [x,y,z] (same units as r).
    """
    ra  = ra_deg * deg2rad
    dec = dec_deg * deg2rad
    x = r * np.cos(dec)*np.cos(ra)
    y = r * np.cos(dec)*np.sin(ra)
    z = r * np.sin(dec)
    return np.array([x, y, z])

def cart_to_sph(vec):
    """
    Input numpy array-like [x,y,z].
    Returns (RA_deg, Dec_deg, r).
    RA in [-180, +180] deg.
    """
    x, y, z = vec
    r = float(np.linalg.norm(vec) + 1e-12)
    dec = rad2deg * math.asin(z / r)
    ra  = rad2deg * math.atan2(y, x)
    return ra, dec, r

# ---------------------- STUR COHERENCE -------------------------
def S_stur(r_Mpc, L0_Mpc):
    """
    STUR coherence:
        S(r) = tanh(x)*(1 - exp(-x)), x = r/L0
    r_Mpc and L0_Mpc can be scalars or arrays.
    """
    x = np.clip(np.asarray(r_Mpc, dtype=float) / float(L0_Mpc), 0.0, 60.0)
    return np.tanh(x) * (1.0 - np.exp(-x))

# ---------------------- HELPERS FOR ANGLES ---------------------
def wrap_ra_180(ra_deg):
    """
    Wrap RA to [-180, +180] deg.
    """
    return (ra_deg + 180.0) % 360.0 - 180.0

# ---------------------- ANCHORS & JWST FIELDS ------------------
def hms(h, m, s):
    """Hours, minutes, seconds -> hours (decimal)."""
    return h + m/60.0 + s/3600.0

def dms(sign, d, m, s):
    """
    sign = +1 or -1; d, m, s positive.
    Returns degrees (decimal).
    """
    sgn = 1 if sign >= 0 else -1
    return sgn * (abs(d) + m/60.0 + s/3600.0)

# Major attractors and one repeller
anchors_raw = [
    # name, RA_deg, Dec_deg, distance_Mpc, is_repeller
    ("Virgo Cluster",
     hms(12,27,0)*15, dms(+1,12,43,0), 16.5, False),

    ("Norma Cluster (Great Attractor)",
     hms(16,14,0)*15, dms(-1,60,52,0), 68.0, False),

    ("Shapley Supercluster",
     hms(13,25,0)*15, dms(-1,30,0,0), 200.0, False),

    ("Dipole Repeller",
     347.8, 7.1, 220.0, True),
]

anchor_names    = [row[0] for row in anchors_raw]
anchor_ra_deg   = np.array([row[1] for row in anchors_raw])
anchor_dec_deg  = np.array([row[2] for row in anchors_raw])
anchor_dist_Mpc = np.array([row[3] for row in anchors_raw])
anchor_is_rep   = np.array([row[4] for row in anchors_raw], dtype=bool)

anchor_xyz = np.array([
    sph_to_cart(anchor_ra_deg[i], anchor_dec_deg[i], anchor_dist_Mpc[i])
    for i in range(len(anchor_names))
])

anchor_colors = {
    "Virgo Cluster": "orange",
    "Norma Cluster (Great Attractor)": "yellow",
    "Shapley Supercluster": "red",
    "Dipole Repeller": "cyan",
}

# JWST deep fields
jwst_raw = [
    # name, RA_deg, Dec_deg, z_max, area_arcmin2
    ("CEERS (Extended Groth Strip)",
     hms(14,19,43)*15, dms(+1,52,53,0), 10.0, 84.0),

    ("JADES (GOODS-South)",
     hms(3,32,38)*15, dms(-1,27,47,0), 14.0, 20.0),

    ("HUDF Field",
     hms(3,32,39)*15, dms(-1,27,47,29), 12.0, 11.0),

    ("SMACS 0723 Cluster Field",
     hms(7,23,16)*15, dms(-1,73,27,0), 13.0, 9.0),
]

jwst_names       = [row[0] for row in jwst_raw]
jwst_ra_deg      = np.array([row[1] for row in jwst_raw])
jwst_dec_deg     = np.array([row[2] for row in jwst_raw])
jwst_z           = np.array([row[3] for row in jwst_raw])
jwst_area_arcmin = np.array([row[4] for row in jwst_raw])
jwst_dist_Mpc    = np.array([comoving_distance_Mpc(z) for z in jwst_z])

jwst_xyz = np.array([
    sph_to_cart(jwst_ra_deg[i], jwst_dec_deg[i], jwst_dist_Mpc[i])
    for i in range(len(jwst_names))
])

jwst_colors = {
    "CEERS (Extended Groth Strip)": "magenta",
    "JADES (GOODS-South)": "lime",
    "HUDF Field": "white",
    "SMACS 0723 Cluster Field": "deepskyblue",
}

# CMB dipole direction (approx)
cmb_ra_deg  = 168.0
cmb_dec_deg = -7.0
cmb_vec = sph_to_cart(cmb_ra_deg, cmb_dec_deg, 1.0)
cmb_vec /= np.linalg.norm(cmb_vec)

# ---------------------- HELICAL FUNNEL GENERATOR --------------
def generate_helical_bundle(axis_vec, r_min, r_max, rep=False):
    """
    Generate a bundle of helical strands from Earth toward axis_vec.
    axis_vec: 3D vector pointing roughly toward the anchor.
    r_min, r_max: radial range (Mpc).
    rep: if True, acts loosely like a repeller at large r
         (slight divergence near endpoint).
    Returns:
        bundle: shape (N_STREAM, N_STEPS_HELIX, 3)
        central: shape (N_STEPS_HELIX, 3)
    """
    axis = np.array(axis_vec, dtype=float)
    axis /= (np.linalg.norm(axis) + 1e-12)

    # Build local orthonormal frame (axis, e1, e2)
    tmp = np.array([0.0, 0.0, 1.0])
    if abs(np.dot(axis, tmp)) > 0.9:
        tmp = np.array([1.0, 0.0, 0.0])
    e1 = np.cross(axis, tmp)
    e1 /= np.linalg.norm(e1)
    e2 = np.cross(axis, e1)

    svals = np.linspace(0.0, 1.5, N_STEPS_HELIX)
    bundle = np.zeros((N_STREAM, N_STEPS_HELIX, 3), dtype=float)

    # Characteristic coherence length along this line
    L0 = max(r_max / 8.0, 1.0)
    base_radius = 0.09 * r_max  # sets overall funnel width

    for k in range(N_STREAM):
        phase = 2.0 * math.pi * k / N_STREAM
        for i, s in enumerate(svals):
            s1 = min(s, 1.0)
            r_here = r_min + 0.5*(r_max - r_min)*(1.0 - math.cos(math.pi * s1))
            # For repeller, bend slightly away near the end
            if rep and s > 1.0:
                r_here *= 1.0 - 0.45 * (s - 1.0)**1.3

            Sval = float(S_stur(r_here, L0))
            helix_r = base_radius * (0.20 + 0.80 * Sval)
            angle   = 6.0*math.pi*s + phase

            pos = axis * r_here
            pos += helix_r * (math.cos(angle)*e1 + math.sin(angle)*e2)

            if rep:
                norm = np.linalg.norm(pos)
                if norm > 0:
                    pos = pos / norm * r_here

            bundle[k, i, :] = pos

    return bundle, bundle[0].copy()

# ---------------------- BUILD HELICAL NETWORK ------------------
helical_bundles = {}
central_helices = {}

# Anchors
for i, name in enumerate(anchor_names):
    bundle, central = generate_helical_bundle(
        axis_vec=anchor_xyz[i],
        r_min=0.0,
        r_max=3.0 * anchor_dist_Mpc[i],
        rep=bool(anchor_is_rep[i])
    )
    helical_bundles[name] = bundle
    central_helices[name] = central

# JWST deep fields (funnels to their max comoving distance)
for i, name in enumerate(jwst_names):
    bundle, central = generate_helical_bundle(
        axis_vec=jwst_xyz[i],
        r_min=0.0,
        r_max=jwst_dist_Mpc[i],
        rep=False
    )
    helical_bundles[name] = bundle
    central_helices[name] = central

# ---------------------- VECTORIZED STUR 3D FIELD --------------
def sample_stur_field_3d(N_samples):
    """
    Sample the STUR field in a sphere of radius R_MAX_MPC.
    Returns:
        pts      : (N,3) positions (Mpc)
        S_values : (N,) signed STUR field
        z_values : (N,) approximate redshift from distance
    """
    u = np.random.rand(N_samples)
    r = R_MAX_MPC * np.cbrt(u)
    theta = np.arccos(1.0 - 2.0*np.random.rand(N_samples))
    phi   = 2.0 * np.pi * np.random.rand(N_samples)

    x = r * np.sin(theta) * np.cos(phi)
    y = r * np.sin(theta) * np.sin(phi)
    z = r * np.cos(theta)
    pts = np.stack([x, y, z], axis=1)

    # Distances to each anchor
    diffs = pts[:, None, :] - anchor_xyz[None, :, :]    # (N, n_anchor, 3)
    dists = np.linalg.norm(diffs, axis=2) + 1e-6        # (N, n_anchor)

    # Signed contributions: attractors (+), repeller (-)
    signs = np.where(anchor_is_rep, -1.0, 1.0)[None, :]   # (1, n_anchor)
    L0s   = np.maximum(anchor_dist_Mpc / 10.0, 1.0)[None, :]

    S_each = S_stur(dists, L0s)                           # (N, n_anchor)
    S_vals = np.sum(signs * S_each / (dists**2), axis=1)  # (N,)

    # Convert radius to redshift
    z_vals = np.array([redshift_from_distance(rr) for rr in r])

    return pts, S_vals, z_vals

field_pts, field_S_raw, field_z = sample_stur_field_3d(N_FIELD_SAMPLES)
S_min, S_max = float(field_S_raw.min()), float(field_S_raw.max())
S_norm = (field_S_raw - S_min) / (S_max - S_min + 1e-12)
z_norm = np.clip(field_z / Z_MAX, 0.0, 1.0)

# Colormap by redshift for 3D & Aitoff
field_colors = plt.cm.plasma(z_norm)

# ---------------------- FIGURE 1: 3D UNIVERSE -----------------
fig1 = plt.figure(figsize=(10, 10))
ax3d = fig1.add_subplot(111, projection="3d")
ax3d.set_title("STUR Universe Atlas ‚Äì 3D Helical Map (v1.0)")

# STUR fog
ax3d.scatter(field_pts[:,0], field_pts[:,1], field_pts[:,2],
             c=field_colors, s=1.1, alpha=0.13, linewidths=0)

# Redshift shells
shell_z_list = [0.1, 0.5, 1.0, 3.0, 5.0, 10.0, 20.0]
theta = np.linspace(0.0, math.pi, 60)
phi   = np.linspace(0.0, 2.0*math.pi, 60)
T, P  = np.meshgrid(theta, phi)

for z_shell in shell_z_list:
    R_shell = comoving_distance_Mpc(z_shell)
    xs = R_shell * np.sin(T) * np.cos(P)
    ys = R_shell * np.sin(T) * np.sin(P)
    zs = R_shell * np.cos(T)

    level = z_shell / Z_MAX
    ax3d.plot_wireframe(xs, ys, zs,
                        color=plt.cm.Greys(0.15 + 0.65*level),
                        linewidth=0.25,
                        alpha=0.18)
    ax3d.text(0.0, 0.0, R_shell,
              f"z={z_shell:g}",
              color="gray",
              fontsize=7,
              ha="center",
              va="bottom")

# Helical funnels to anchors
for name in anchor_names:
    col = anchor_colors.get(name, "white")
    bundle = helical_bundles[name]
    for k in range(N_STREAM):
        pts = bundle[k]
        ax3d.plot(pts[:,0], pts[:,1], pts[:,2],
                  color=col, alpha=0.25, linewidth=0.8)

# Helical funnels to JWST fields
for name in jwst_names:
    col = jwst_colors.get(name, "white")
    bundle = helical_bundles[name]
    for k in range(N_STREAM):
        pts = bundle[k]
        ax3d.plot(pts[:,0], pts[:,1], pts[:,2],
                  color=col, alpha=0.55, linewidth=1.0)

# Plot anchor positions
for i, name in enumerate(anchor_names):
    x, y, z = anchor_xyz[i]
    col = anchor_colors.get(name, "white")
    ax3d.scatter([x], [y], [z],
                 color=col, s=120,
                 marker="*", edgecolors="black", linewidths=0.8)
    ax3d.text(x, y, z, name.split()[0],
              color=col, fontsize=9, ha="center", va="bottom")

# JWST as triangles
for i, name in enumerate(jwst_names):
    x, y, z = jwst_xyz[i]
    col = jwst_colors.get(name, "white")
    ax3d.scatter([x], [y], [z],
                 color=col, s=80,
                 marker="^", edgecolors="black", linewidths=0.7)
    ax3d.text(x, y, z, name.split()[0],
              color=col, fontsize=8, ha="center", va="bottom")

# Earth at origin
ax3d.scatter([0], [0], [0], color="white", s=60)
ax3d.text(0, 0, 0, "Earth", color="white", fontsize=9,
          ha="center", va="top")

# CMB dipole arrow
cmb_len = comoving_distance_Mpc(0.02)
cmb_end = cmb_vec * cmb_len
ax3d.quiver(0, 0, 0,
            cmb_end[0], cmb_end[1], cmb_end[2],
            color="lime", linewidth=2, arrow_length_ratio=0.12)
ax3d.text(cmb_end[0], cmb_end[1], cmb_end[2],
          "CMB Dipole", color="lime", fontsize=8,
          ha="center", va="bottom")

ax3d.set_xlabel("x (Mpc)")
ax3d.set_ylabel("y (Mpc)")
ax3d.set_zlabel("z (Mpc)")

def set_equal_aspect_3d(ax):
    limits = np.array([ax.get_xlim3d(),
                       ax.get_ylim3d(),
                       ax.get_zlim3d()])
    spans = limits[:,1] - limits[:,0]
    centers = np.mean(limits, axis=1)
    radius = 0.5 * max(spans)
    ax.set_xlim3d([centers[0] - radius, centers[0] + radius])
    ax.set_ylim3d([centers[1] - radius, centers[1] + radius])
    ax.set_zlim3d([centers[2] - radius, centers[2] + radius])

set_equal_aspect_3d(ax3d)
fig1.tight_layout()

try:
    fig1.savefig("STUR_Universe_3D_v1.png", dpi=260, bbox_inches="tight")
except Exception:
    pass

# ---------------------- FIGURE 2: AITOFF ALL-SKY ---------------
fig2 = plt.figure(figsize=(10, 6))
axA = fig2.add_subplot(111, projection="aitoff")
axA.set_title("STUR Universe Atlas ‚Äì Aitoff All-Sky Projection (v1.0)")

# Subsample for plotting
idx_allsky = np.linspace(0, len(field_pts)-1, 30000, dtype=int)
ra_all, dec_all = [], []
cols_all = []

for i in idx_allsky:
    ra_deg, dec_deg, r = cart_to_sph(field_pts[i])
    ra_wrap = wrap_ra_180(ra_deg)
    ra_all.append(ra_wrap * deg2rad)
    dec_all.append(dec_deg * deg2rad)
    cols_all.append(field_colors[i])

ra_all = np.array(ra_all)
dec_all = np.array(dec_all)
cols_all = np.array(cols_all)

axA.scatter(ra_all, dec_all,
            c=cols_all, s=1.1, alpha=0.18)

# Helper: project a central helix
def plot_central_helix_on_aitoff(pts, color, lw=1.5):
    raL, decL = [], []
    for p in pts:
        ra_deg, dec_deg, r = cart_to_sph(p)
        ra_wrap = wrap_ra_180(ra_deg)
        raL.append(ra_wrap * deg2rad)
        decL.append(dec_deg * deg2rad)
    axA.plot(raL, decL, color=color, alpha=0.9, linewidth=lw)

# Anchors
for name in anchor_names:
    plot_central_helix_on_aitoff(central_helices[name],
                                 anchor_colors.get(name, "white"),
                                 lw=1.7)

# JWST deep fields
for name in jwst_names:
    plot_central_helix_on_aitoff(central_helices[name],
                                 jwst_colors.get(name, "white"),
                                 lw=1.4)

axA.grid(True)

try:
    fig2.savefig("STUR_Universe_Aitoff_v1.png", dpi=260, bbox_inches="tight")
except Exception:
    pass

fig2.tight_layout()

# ---------------------- FIGURE 3: 4-PANEL SKYBOX ---------------
fig3, axes3 = plt.subplots(2, 2, figsize=(10, 8), subplot_kw={"projection": None})
fig3.suptitle("STUR Universe Atlas ‚Äì 4-Panel RA Skybox (Earth POV)", fontsize=12)

# Compute RA/Dec for all field points (for reuse)
ra_all_deg, dec_all_deg = [], []
for i in range(len(field_pts)):
    ra_deg, dec_deg, r = cart_to_sph(field_pts[i])
    ra_all_deg.append(wrap_ra_180(ra_deg))
    dec_all_deg.append(dec_deg)
ra_all_deg = np.array(ra_all_deg)
dec_all_deg = np.array(dec_all_deg)

# Define RA sectors
sectors = [
    ("RA ‚àà [-180¬∞, -90¬∞]", -180.0, -90.0),
    ("RA ‚àà [-90¬∞, 0¬∞]",    -90.0,   0.0),
    ("RA ‚àà [0¬∞, 90¬∞]",       0.0,  90.0),
    ("RA ‚àà [90¬∞, 180¬∞]",    90.0, 180.0),
]

def plot_sector(ax, title, ra_min, ra_max):
    mask = (ra_all_deg >= ra_min) & (ra_all_deg < ra_max)
    # Further subsample for speed
    idx_sector = np.where(mask)[0]
    if len(idx_sector) > 20000:
        idx_sector = np.random.choice(idx_sector, size=20000, replace=False)
    ax.scatter(ra_all_deg[idx_sector],
               dec_all_deg[idx_sector],
               c=z_norm[idx_sector],
               cmap="plasma",
               s=1.2,
               alpha=0.26)
    ax.set_title(title, fontsize=9)
    ax.set_xlim(ra_min, ra_max)
    ax.set_ylim(-90, 90)
    ax.set_xlabel("RA (deg)")
    ax.set_ylabel("Dec (deg)")
    ax.grid(alpha=0.25, linestyle="--")

    # Overplot anchors that fall in this RA range
    for i, name in enumerate(anchor_names):
        ra = wrap_ra_180(anchor_ra_deg[i])
        dec = anchor_dec_deg[i]
        if ra_min <= ra < ra_max:
            col = anchor_colors.get(name, "white")
            ax.scatter([ra], [dec],
                       color=col, s=40, marker="*", edgecolors="black", linewidths=0.6)
            ax.text(ra, dec, name.split()[0],
                    color=col, fontsize=7, ha="center", va="bottom")

    # Overplot JWST fields
    for i, name in enumerate(jwst_names):
        ra = wrap_ra_180(jwst_ra_deg[i])
        dec = jwst_dec_deg[i]
        if ra_min <= ra < ra_max:
            col = jwst_colors.get(name, "white")
            ax.scatter([ra], [dec],
                       color=col, s=30, marker="^", edgecolors="black", linewidths=0.5)
            ax.text(ra, dec, name.split()[0],
                    color=col, fontsize=7, ha="center", va="bottom")

# Lay out the 4 panels
for ax, (label, ra_min, ra_max) in zip(axes3.flatten(), sectors):
    plot_sector(ax, label, ra_min, ra_max)

fig3.tight_layout(rect=[0, 0.03, 1, 0.95])

try:
    fig3.savefig("STUR_Universe_Skybox4_v1.png", dpi=260, bbox_inches="tight")
except Exception:
    pass

# ---------------------- FIGURE 4: S(r) RADIAL PROFILES --------
fig4, ax4 = plt.subplots(figsize=(9, 5))
ax4.set_title("STUR Coherence S(r) Along Anchor Lines")
ax4.set_xlabel("Radius r (Mpc)")
ax4.set_ylabel("S(r)")

for i, name in enumerate(anchor_names):
    r_max = 3.0 * anchor_dist_Mpc[i]
    r_vals = np.linspace(0.0, r_max, 400)
    L0 = max(anchor_dist_Mpc[i] / 5.0, 1.0)
    S_vals = S_stur(r_vals, L0)
    col = anchor_colors.get(name, "white")
    ax4.plot(r_vals, S_vals, label=name, color=col, linewidth=1.4)

ax4.set_ylim(0.0, 1.05)
ax4.grid(alpha=0.25, linestyle="--")
ax4.legend(fontsize=7)

fig4.tight_layout()

try:
    fig4.savefig("STUR_Universe_S_profile_v1.png", dpi=260, bbox_inches="tight")
except Exception:
    pass

plt.show()

# ---------------------- JSON ATLAS EXPORT ----------------------
def vec_to_list(v):
    return [float(v[0]), float(v[1]), float(v[2])]

# Subsample for JSON
N_field_json = min(N_FIELD_SUB_JSON, len(field_pts))
json_idx = np.linspace(0, len(field_pts)-1, N_field_json, dtype=int)

# Subsample each central helix
def subsample_central(pts, N_sub):
    N = pts.shape[0]
    if N <= N_sub:
        return [vec_to_list(p) for p in pts]
    idx = np.linspace(0, N-1, N_sub, dtype=int)
    return [vec_to_list(pts[i]) for i in idx]

atlas = {
    "model": "STUR Universe Atlas v1.0",
    "description": (
        "Helical, STUR-modulated universe skeleton from Earth's POV, "
        "with anchors (Virgo, GA, Shapley, Repeller), JWST deep fields, "
        "and STUR field samples in comoving ŒõCDM coordinates."
    ),
    "cosmology": {
        "H0_km_s_Mpc": float(H0_kms),
        "Omega_m": float(Omega_m),
        "Omega_Lambda": float(Omega_L),
        "Z_max": float(Z_MAX),
        "R_max_Mpc": float(R_MAX_MPC),
        "note": "Flat ŒõCDM toy background for distance-redshift conversion."
    },
    "configuration": {
        "N_z_grid": int(N_ZGRID),
        "N_stream": int(N_STREAM),
        "N_steps_helix": int(N_STEPS_HELIX),
        "N_field_samples": int(N_FIELD_SAMPLES),
        "N_field_samples_in_JSON": int(N_field_json),
        "N_helix_points_in_JSON": int(N_HELIX_SUB_JSON)
    },
    "anchors": [],
    "jwst_pointings": [],
    "central_helices": {},
    "stur_field_subsample": {
        "xyz_Mpc": [],
        "redshift": [],
        "S_value_raw": [],
        "S_value_norm": []
    }
}

# Anchors
for i, name in enumerate(anchor_names):
    atlas["anchors"].append({
        "name": name,
        "RA_deg": float(anchor_ra_deg[i]),
        "Dec_deg": float(anchor_dec_deg[i]),
        "distance_Mpc": float(anchor_dist_Mpc[i]),
        "is_repeller": bool(anchor_is_rep[i]),
        "xyz_Mpc": vec_to_list(anchor_xyz[i]),
        "L0_S_profile_Mpc": float(max(anchor_dist_Mpc[i] / 5.0, 1.0)),
        "data_note": (
            "Approximate sky position and distance. This is a schematic atlas, "
            "not a precision catalog."
        )
    })

# JWST fields
for i, name in enumerate(jwst_names):
    atlas["jwst_pointings"].append({
        "name": name,
        "RA_deg": float(jwst_ra_deg[i]),
        "Dec_deg": float(jwst_dec_deg[i]),
        "z_max": float(jwst_z[i]),
        "footprint_arcmin2": float(jwst_area_arcmin[i]),
        "distance_Mpc": float(jwst_dist_Mpc[i]),
        "xyz_Mpc": vec_to_list(jwst_xyz[i]),
        "data_note": (
            "Footprints and redshifts are order-of-magnitude descriptors, "
            "used for building a conceptual STUR atlas."
        )
    })

# Central helices
for name, pts in central_helices.items():
    atlas["central_helices"][name] = {
        "N_points_full": int(pts.shape[0]),
        "xyz_Mpc_subsample": subsample_central(pts, N_HELIX_SUB_JSON)
    }

# STUR field subset
for i in json_idx:
    atlas["stur_field_subsample"]["xyz_Mpc"].append(
        vec_to_list(field_pts[i])
    )
    atlas["stur_field_subsample"]["redshift"].append(
        float(field_z[i])
    )
    atlas["stur_field_subsample"]["S_value_raw"].append(
        float(field_S_raw[i])
    )
    atlas["stur_field_subsample"]["S_value_norm"].append(
        float(S_norm[i])
    )

# Print JSON atlas
print(json.dumps(atlas, indent=2))
      </textarea>
    </div>

    <div class="button-row">
      <button class="btn primary" id="copyBtnMain">üìã Copy STUR Universe Atlas Code</button>
      <button class="btn" id="selectBtnMain">üîé Select all code</button>
      <a class="btn accent" href="../jupyterlite/index.html" target="_blank">‚ñ∂ Run in JupyterLite</a>
      <a class="btn" href="../index.html">üè† Back to STUR Physics Lab</a>
    </div>

    <div class="footer-nav">
      <div class="left">
        <span class="chip">Author: Sheldon L. Lindberg (2025)</span>
        <span class="chip">Universe Atlas: v1.0</span>
      </div>
      <div class="right">
        <span class="tiny">
          All future STUR universe modules (quark‚Üícosmic ladder, helix labs) can reuse this atlas JSON
          so the whole STUR-Physics-Lab speaks one consistent cosmic language.
        </span>
      </div>
    </div>
  </section>

  <!-- INTERPRETING THE ATLAS -->
  <section class="panel alt">
    <div class="panel-header">
      <div class="panel-title">How to read the STUR Universe Atlas</div>
      <div class="panel-tag">3D map ¬∑ all-sky ¬∑ RA skybox ¬∑ coherence curves</div>
    </div>
    <div class="grid-two">
      <div>
        <p><strong>Figure 1 ‚Äì 3D STUR Universe</strong></p>
        <ul>
          <li>
            Colored fog: random samples of the STUR field, color-coded by redshift.
          </li>
          <li>
            Transparent wire shells: constant-redshift surfaces (<code>z</code> labels).
          </li>
          <li>
            Helical tubes to Virgo, Great Attractor, Shapley, Repeller and JWST fields.
          </li>
          <li>
            Earth at the origin, with a green arrow for the CMB dipole direction.
          </li>
        </ul>
        <p><strong>Figure 2 ‚Äì Aitoff all-sky</strong></p>
        <ul>
          <li>
            RA/Dec sky plot of the same STUR samples (now flattened to the sphere).
          </li>
          <li>
            Central helices appear as colored curves across the sky.
          </li>
          <li>
            Use this as a starting framework to overlay real catalogs (galaxies, clusters, etc.).
          </li>
        </ul>
      </div>
      <div>
        <p><strong>Figure 3 ‚Äì 4-panel RA skybox</strong></p>
        <ul>
          <li>
            The full sky is split into four RA sectors:
            [-180¬∞, -90¬∞], [-90¬∞, 0¬∞], [0¬∞, 90¬∞], [90¬∞, 180¬∞].
          </li>
          <li>
            Each panel shows STUR samples in that RA slice, color-coded by redshift.
          </li>
          <li>
            Anchors and JWST deep fields are overplotted as stars and triangles with labels.
          </li>
        </ul>
        <p><strong>Figure 4 ‚Äì S(r) curves</strong></p>
        <ul>
          <li>
            Coherence profiles <span class="inline-math">S(r)</span> along each anchor‚Äôs line of sight.
          </li>
          <li>
            Where <span class="inline-math">S(r)</span> peaks, that anchor is most ‚Äúefficient‚Äù at
            structuring flows in the STUR picture.
          </li>
        </ul>
        <p class="tiny">
          The JSON atlas at the end is your ‚Äúsave game‚Äù for the universe:
          you can load it in other STUR labs, machine learning experiments,
          or parameter scans without recomputing the whole field.
        </p>
      </div>
    </div>
  </section>

</main>

<button class="scroll-top" id="scrollTopBtn">‚Üë Top</button>

<script>
  (function() {
    const codeElem = document.getElementById("sturCode");
    const copyButtons = [
      document.getElementById("copyBtnTop"),
      document.getElementById("copyBtnMain")
    ].filter(Boolean);
    const selectButtons = [
      document.getElementById("selectBtnTop"),
      document.getElementById("selectBtnMain")
    ].filter(Boolean);

    function selectAll() {
      codeElem.focus();
      codeElem.select();
    }

    function copyCode() {
      selectAll();
      try {
        const ok = document.execCommand("copy");
        if (ok) {
          copyButtons.forEach(btn => btn.textContent = "‚úî Copied!");
          setTimeout(() => {
            copyButtons.forEach(btn => {
              if (btn.id === "copyBtnMain") {
                btn.textContent = "üìã Copy STUR Universe Atlas Code";
              } else {
                btn.textContent = "Copy";
              }
            });
          }, 1600);
        }
      } catch (e) {
        console.error(e);
      }
    }

    copyButtons.forEach(btn => btn.addEventListener("click", copyCode));
    selectButtons.forEach(btn => btn.addEventListener("click", selectAll));

    const scrollBtn = document.getElementById("scrollTopBtn");
    window.addEventListener("scroll", () => {
      if (window.scrollY > 320) {
        scrollBtn.classList.add("show");
      } else {
        scrollBtn.classList.remove("show");
      }
    });
    scrollBtn.addEventListener("click", () => {
      window.scrollTo({ top: 0, behavior: "smooth" });
    });
  })();
</script>

</body>
</html>
