<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STUR Weather – Hybrid Atmospheric Field Simulation</title>
<style>
  body{
    background:#050814;
    color:#e6edf3;
    font-family:"Courier New",monospace;
    margin:0;
    padding:2rem;
  }
  h1{
    color:#ffaa00;
    text-align:center;
  }
  h2{
    color:#ffcc33;
    margin-top:2rem;
  }
  .desc{
    max-width:900px;
    margin:0 auto 1.5rem auto;
    line-height:1.5;
  }
  pre{
    background:#0a0f1f;
    color:#00ffcc;
    padding:1rem;
    border-radius:8px;
    overflow-x:auto;
    font-size:0.9rem;
    box-shadow:0 0 18px #ffaa0040;
    white-space:pre;
  }
  button{
    background:#ffaa00;
    color:#050814;
    border:none;
    border-radius:6px;
    padding:10px 20px;
    font-weight:bold;
    cursor:pointer;
    margin:6px;
    transition:0.2s;
  }
  button:hover{
    background:#ffcc33;
  }
  footer{
    margin-top:2rem;
    text-align:center;
    font-size:0.9em;
    color:#999;
  }
  a{color:#66ccff;}
</style>
</head>
<body>

<h1>STUR Weather – Hybrid Atmospheric Field Simulation</h1>

<h2>Derivation Overview</h2>
<div class="desc">
<p>
In the STUR Unified Resistance framework, an atmospheric column is modeled as a
cloud of parcels subject to a hybrid force combining Coulomb, Newtonian gravity
and a short range strong like term, plus a spin torque contribution.
For a parcel at position <code>r</code> with velocity <code>v</code>, the total STUR force is
</p>

<p style="text-align:center;">
F<sub>STUR</sub>(r) = S(r,L₀)
[ k<sub>e</sub> q₁ q₂ / r² − G m₁ m₂ / r² + α<sub>s</sub> ( (1 − e<sup>−r/λ</sup>) / r² + σ r ) ] r̂
+ γ₀ e<sup>−r/ℓ<sub>B</sub></sup> (S × B),
</p>

<p>
with STUR radial modulator
</p>

<p style="text-align:center;">
S(r,L₀) = tanh(r / L₀) (1 − e<sup>−r / L₀</sup>).
</p>

<p>
A simple fluid contribution is added,
</p>

<p style="text-align:center;">
F<sub>fluid</sub> = −(1 / ρ) ∇P + ν ξ,
</p>

<p>
where ρ is air density, P is local pressure and ξ is a random vector that models
small scale turbulence. Each parcel carries temperature T and pressure P that are
updated by vertical motion against gravity.
</p>

<p>
We discretize an 8 × 8 × 8 grid over a 2 km by 2 km horizontal region and
0–500 m vertically. At each timestep Δt we apply
</p>

<ul>
  <li>v(t + Δt) = v(t) + (F<sub>fluid</sub> + F<sub>STUR</sub>) Δt</li>
  <li>r(t + Δt) = r(t) + v(t) Δt</li>
  <li>T and P updated using vertical velocity and a simple lapse like rule</li>
</ul>

<p>
After n steps the script classifies emergent structures:
</p>

<ul>
  <li><b>Microbursts</b>: parcels with strong downward vertical velocity
      (v<sub>z</sub> below −10 m/s)</li>
  <li><b>Funnels</b>: parcels with large vertical angular momentum
      L<sub>z</sub> = v<sub>x</sub> y − v<sub>y</sub> x in the horizontal plane</li>
  <li><b>Heat domes</b>: parcels with T greater than 300 K</li>
</ul>

<p>
The Python block below:
</p>
<ul>
  <li>runs the full 3D STUR weather evolution on the grid,</li>
  <li>produces three 3D Matplotlib plots (one per event type),</li>
  <li>prints a JSON summary with grid, time, event counts and field ranges.</li>
</ul>
</div>

<h2>Python Simulation (copy &amp; run in Jupyter / JupyterLite)</h2>

<pre id="codeBlock">#!/usr/bin/env python3
# ===============================================================
# STUR Weather – Hybrid Atmospheric Field Simulation
# Three event plots + JSON summary
# ===============================================================
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  # required for 3D projection
import json

# ----------------- CONSTANTS -----------------------------------
k_e  = 8.9875e9      # Coulomb constant (N m^2 / C^2)
G    = 6.6743e-11    # Gravitational constant (N m^2 / kg^2)
sigma_strong = 1e-5  # strong like parameter
lam  = 1e-15         # range (m)
lB   = 1e2           # spin decay length (m)

q1, q2 = 1e-6, 1e-6  # charges (C)
m1, m2 = 1e3, 1e3    # effective masses (kg)
S_vec   = np.array([0.0, 0.0, 1.0])
B_vec   = np.array([0.0, 0.0, 1.0])

rho_air = 1.2        # kg/m^3
g       = 9.81       # m/s^2
nu      = 1e-2       # effective viscosity coefficient

L0_mod  = 1e5        # STUR radial modulation scale
gamma0  = 1e-3       # spin torque coefficient
dt      = 0.5        # time step (s)
n_steps = 80         # number of evolution steps
np.random.seed(0)    # reproducible noise

V_MAX   = 80.0       # cap on parcel speed (m/s)

# ----------------- STUR MODULATOR & FORCE ----------------------
def S_r(r, L0):
    """
    STUR radial modulator S(r,L0).
    """
    return np.tanh(r / L0) * (1.0 - np.exp(-r / L0))

def F_sheldon(r_vec, v_vec, L0=L0_mod, gamma0=gamma0, alpha_s=1e-9):
    """
    Unified Coulomb–gravity–strong plus spin torque force on a parcel.
    r_vec: position (3,)
    v_vec: velocity (3,) – kept for possible extensions
    """
    r_norm = float(np.linalg.norm(r_vec))
    if r_norm == 0.0:
        return np.zeros(3, dtype=float)
    r_hat  = r_vec / r_norm
    coulomb = k_e * q1 * q2 / (r_norm**2)
    grav    = -G * m1 * m2 / (r_norm**2)
    strong  = alpha_s * ((1.0 - np.exp(-r_norm / lam)) / (r_norm**2)
                         + sigma_strong * r_norm)
    F_rad   = S_r(r_norm, L0) * (coulomb + grav + strong) * r_hat
    F_spin  = gamma0 * np.exp(-r_norm / lB) * np.cross(S_vec, B_vec)
    return F_rad + F_spin

# ----------------- ATMOSPHERIC GRID ----------------------------
nx, ny, nz = 8, 8, 8
X, Y, Z = np.meshgrid(
    np.linspace(-1e3, 1e3, nx),
    np.linspace(-1e3, 1e3, ny),
    np.linspace(0.0, 500.0, nz)
)

pos = np.stack([X.flatten(), Y.flatten(), Z.flatten()], axis=-1).astype(float)
vel = np.zeros_like(pos)
T   = np.ones(pos.shape[0], dtype=float) * 290.0      # K
P   = np.ones(pos.shape[0], dtype=float) * 101325.0   # Pa

# ----------------- TIME EVOLUTION ------------------------------
for step in range(n_steps):
    # background horizontal shear in x, proportional to y
    vel[:, 0] = vel[:, 0] + 0.0001 * (pos[:, 1] / 1e3)

    for i in range(pos.shape[0]):
        # fluid contribution: vertical pressure deviation plus random turbulence
        F_fluid = np.array([0.0,
                            0.0,
                            (P[i] - 101325.0) / 50.0], dtype=float)
        F_fluid = F_fluid * (-1.0 / rho_air) + nu * np.random.randn(3) * 0.01

        # STUR hybrid force
        F_total = F_fluid + F_sheldon(pos[i], vel[i])

        # update velocity
        vel[i] = vel[i] + F_total * dt
        vnorm = float(np.linalg.norm(vel[i]))
        if vnorm > V_MAX:
            vel[i] = vel[i] * (V_MAX / vnorm)

        # update position
        pos[i] = pos[i] + vel[i] * dt

        # vertical coupling into temperature and pressure
        vz = vel[i, 2]
        T[i] = T[i] + (-(g / 1000.0) * vz * dt)
        P[i] = P[i] - 0.05 * vz * dt

# ----------------- EVENT DETECTION -----------------------------
# microbursts: strong downward vertical velocity
microbursts = np.less(vel[:, 2], -10.0)

# funnels: strong vertical angular momentum about z axis
r2d = pos[:, :2]
v2d = vel[:, :2]
Lz  = v2d[:, 0] * r2d[:, 1] - v2d[:, 1] * r2d[:, 0]
funnels = np.greater(np.abs(Lz), 0.05)

# heat domes: elevated temperature
heat_domes = np.greater(T, 300.0)

# ----------------- FIELD MAGNITUDES ----------------------------
speed = np.sqrt(np.sum(vel**2, axis=1))

# ----------------- PLOTTING (ONE FIGURE PER EVENT) ------------
# 1) Microbursts
fig1 = plt.figure(figsize=(5, 4))
ax1 = fig1.add_subplot(111, projection="3d")
ax1.scatter(pos[:, 0], pos[:, 1], pos[:, 2],
            c="#444444", s=5, alpha=0.3)
ax1.scatter(pos[microbursts, 0], pos[microbursts, 1], pos[microbursts, 2],
            c="cyan", s=25, label="Microbursts")
ax1.set_title("Microbursts (vz below -10 m/s)")
ax1.set_xlim(-1e3, 1e3)
ax1.set_ylim(-1e3, 1e3)
ax1.set_zlim(0, 500)
ax1.set_xlabel("X (m)")
ax1.set_ylabel("Y (m)")
ax1.set_zlabel("Z (m)")
ax1.legend(loc="best")

plt.show()

# 2) Funnels
fig2 = plt.figure(figsize=(5, 4))
ax2 = fig2.add_subplot(111, projection="3d")
ax2.scatter(pos[:, 0], pos[:, 1], pos[:, 2],
            c="#444444", s=5, alpha=0.3)
ax2.scatter(pos[funnels, 0], pos[funnels, 1], pos[funnels, 2],
            c="magenta", s=25, label="Funnels")
ax2.set_title("Funnels (Lz magnitude greater than 0.05)")
ax2.set_xlim(-1e3, 1e3)
ax2.set_ylim(-1e3, 1e3)
ax2.set_zlim(0, 500)
ax2.set_xlabel("X (m)")
ax2.set_ylabel("Y (m)")
ax2.set_zlabel("Z (m)")
ax2.legend(loc="best")

plt.show()

# 3) Heat domes
fig3 = plt.figure(figsize=(5, 4))
ax3 = fig3.add_subplot(111, projection="3d")
ax3.scatter(pos[:, 0], pos[:, 1], pos[:, 2],
            c="#444444", s=5, alpha=0.3)
ax3.scatter(pos[heat_domes, 0], pos[heat_domes, 1], pos[heat_domes, 2],
            c="red", s=25, label="Heat Domes")
ax3.set_title("Heat Domes (T above 300 K)")
ax3.set_xlim(-1e3, 1e3)
ax3.set_ylim(-1e3, 1e3)
ax3.set_zlim(0, 500)
ax3.set_xlabel("X (m)")
ax3.set_ylabel("Y (m)")
ax3.set_zlabel("Z (m)")
ax3.legend(loc="best")

plt.show()

# ----------------- JSON SUMMARY -------------------------------
summary = {
    "model": "STUR Weather Hybrid Atmosphere (with event plots)",
    "grid": {
        "nx": int(nx),
        "ny": int(ny),
        "nz": int(nz),
        "n_parcels": int(pos.shape[0])
    },
    "time": {
        "dt_s": float(dt),
        "n_steps": int(n_steps),
        "total_time_s": float(dt * n_steps)
    },
    "events": {
        "microbursts_count": int(np.sum(microbursts)),
        "microbursts_fraction": float(np.mean(microbursts)),
        "funnels_count": int(np.sum(funnels)),
        "funnels_fraction": float(np.mean(funnels)),
        "heat_domes_count": int(np.sum(heat_domes)),
        "heat_domes_fraction": float(np.mean(heat_domes))
    },
    "fields": {
        "T_min_K": float(np.min(T)),
        "T_max_K": float(np.max(T)),
        "P_min_Pa": float(np.min(P)),
        "P_max_Pa": float(np.max(P)),
        "vz_min_m_per_s": float(np.min(vel[:, 2])),
        "vz_max_m_per_s": float(np.max(vel[:, 2])),
        "speed_min_m_per_s": float(np.min(speed)),
        "speed_max_m_per_s": float(np.max(speed)),
        "Lz_min": float(np.min(Lz)),
        "Lz_max": float(np.max(Lz))
    }
}

# optional small sample of parcels to inspect
sample_indices = list(range(0, min(5, pos.shape[0])))
sample_data = []
for idx in sample_indices:
    sample_data.append({
        "index": int(idx),
        "pos": [float(x) for x in pos[idx]],
        "vel": [float(x) for x in vel[idx]],
        "T_K": float(T[idx]),
        "P_Pa": float(P[idx])
    })
summary["sample_parcels"] = sample_data

print("JSON summary:")
print(json.dumps(summary, indent=2))
print("STUR Weather hybrid simulation with event plots complete.")</pre>

<div style="text-align:center;">
  <button onclick="copyCode()">Copy Script</button>
  <button onclick="openRunner()">Open Jupyter Lite</button>
</div>

<footer>
© 2025 STUR Physics Lab | Unified Resistance Framework | STUR Weather Simulation
</footer>

<script>
function copyCode(){
  const code = document.getElementById("codeBlock").innerText;
  navigator.clipboard.writeText(code);
  alert("STUR Weather simulation code copied to clipboard.");
}
function openRunner(){
  window.open("https://jupyter.org/try-jupyter/lab/","_blank");
}
</script>

</body>
</html>
