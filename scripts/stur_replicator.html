<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>üç± STUR Replicator ‚Äì Stress-to-Failure Visualization</title>
<style>
 body{background:#050814;color:#e6edf3;font-family:'Courier New',monospace;margin:0;padding:2rem;}
 h1{color:#ffaa00;text-align:center;}
 h2{color:#ffcc33;margin-top:2rem;}
 .desc{max-width:900px;margin:0 auto 1.5rem auto;line-height:1.5;}
 pre{background:#0a0f1f;padding:1rem;border-radius:8px;overflow-x:auto;color:#00ffcc;
     line-height:1.4;box-shadow:0 0 20px #ffaa0055;font-size:0.9rem;}
 footer{margin-top:2rem;text-align:center;font-size:0.9em;color:#aaa;}
 a{color:#66ccff;text-decoration:none;}
 a:hover{color:#99e0ff;}
 button{
   background:#0e1624;
   color:#5ad0ff;
   border:1px solid #5ad0ff;
   padding:8px 14px;
   border-radius:6px;
   cursor:pointer;
   font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;
   font-size:0.9em;
   margin:4px;
   transition:background 0.3s;
 }
 button:hover{background:#152033;}
 .nav-buttons{text-align:center;margin:20px 0 10px 0;}
</style>
</head>
<body>

<h1>üç± STUR Replicator<br>Stress-to-Failure Envelope Visualization</h1>

<p class="desc">
This module is <b>Step 4</b> in the STUR Replicator chain.  
It takes the full <code>results</code> dataset from Step 1 (megascale stress-to-failure with  
<code>sigma_dS = 5√ó10‚Åª¬≥</code>, <code>alpha_relief = 0.3</code>) and generates:
</p>
<ul class="desc">
  <li><b>Failure-mode envelope vs mass</b> for each class (inert, food, organ).</li>
  <li><b>Energy fraction</b> <code>E_need / (m c¬≤)</code> vs mass colored by failure mode.</li>
  <li><b>Worst-case entropy gradient</b> <code>dS_worst</code> vs mass linking coherence noise to collapse.</li>
</ul>

<h2>Derivation Overview</h2>
<div class="desc">
<p>
Step 1 integrates a unified-resistance equation for replicator classes (inert shells, food-grade products,
and full organs) over runtime <code>t_s</code>, sampling noisy entropy gradients <code>dS</code> and
bandwidth <code>Œ©</code>. Each sampled configuration yields:
</p>
<ul>
  <li><code>mass_kg</code> ‚Äì object mass;</li>
  <li><code>E_need_J</code>, <code>E_feed_J</code> ‚Äì energy needed vs supplied;</li>
  <li><code>ratio_vs_mc2 = E_need_J / (m c¬≤)</code> ‚Äì fractional energy cost;</li>
  <li><code>dS_mean</code>, <code>dS_worst</code> ‚Äì mean and worst entropy gradients;</li>
  <li><code>failure_mode ‚àà {power, biology, stable}</code> ‚Äì limiting factor.</li>
</ul>
<p>
This Step 4 visualization builds:
</p>
<ol>
  <li>Failure-mode envelope vs log mass.</li>
  <li>Scatter of <code>E_need/(m c¬≤)</code> vs mass, colored by mode.</li>
  <li>Scatter of <code>dS_worst</code> vs mass, correlating noise to collapse.</li>
</ol>
<p>
It also emits a JSON summary of real <code>results</code> (no synthetic data), listing per-class stats.
</p>
</div>

<h2>Python Visualization (copy &amp; run after Step 1)</h2>

<pre id="codeBlock">#!/usr/bin/env python3
"""
STUR Replicator ‚Äì Step 4 Visualization
--------------------------------------
Visualizes and summarizes real Step-1 `results` datasets.
"""

import numpy as np, matplotlib.pyplot as plt, json

# ---------- helpers ----------
def get_arrays_for_time(results,t_sel):
    out={}
    for r in results:
        if abs(r["t_s"]-t_sel)<1e-9:
            c=r["class"];out.setdefault(c,{"mass":[],"ratio":[],"mode":[],"dS_worst":[]})
            out[c]["mass"].append(r["mass_kg"])
            out[c]["ratio"].append(r["ratio_vs_mc2"])
            out[c]["mode"].append(r["failure_mode"])
            out[c]["dS_worst"].append(r["dS_worst"])
    for c in out:
        idx=np.argsort(out[c]["mass"])
        for k in out[c]: out[c][k]=list(np.array(out[c][k])[idx])
    return out

mode_color={"stable":"green","power":"orange","biology":"red"}
mode_marker={"stable":"o","power":"^","biology":"s"}

def scatter_mode(ax,m,v,modes,cls,y_lbl,title):
    for mi,vi,fi in zip(m,v,modes):
        ax.scatter(mi,vi,c=mode_color[fi],marker=mode_marker[fi],
                   edgecolors="black",alpha=0.8,label=f"{cls}-{fi}")
    ax.set_xscale("log");ax.set_xlabel("Mass (kg)")
    ax.set_ylabel(y_lbl);ax.set_title(title)
    ax.grid(True,which="both",ls=":")
    h,l=ax.get_legend_handles_labels()
    u=dict(zip(l,h));ax.legend(u.values(),u.keys(),fontsize=7)

# ---------- 1) failure mode vs mass ----------
mode_num={"power":0,"biology":1,"stable":2}
def plot_failure_mode_step(results,t_sel):
    d=get_arrays_for_time(results,t_sel)
    plt.figure(figsize=(7,4))
    for i,c in enumerate(["inert","food","organ"]):
        if c not in d: continue
        m=np.array(d[c]["mass"]);v=np.array([mode_num[x] for x in d[c]["mode"]])
        o=np.argsort(m);plt.step(m[o],v[o]+0.05*i,where="post",label=f"{c} (t={t_sel:.0f}s)")
    plt.xscale("log");plt.yticks([0,1,2],["power fail","bio fail","stable"])
    plt.xlabel("Mass (kg)");plt.ylabel("Failure Mode")
    plt.title(f"STUR Replicator Failure Mode Envelope @ t={t_sel:.0f}s")
    plt.grid(True,which="both",ls=":");plt.legend(fontsize=8);plt.tight_layout();plt.show()

# ---------- 2) ratio vs mass ----------
def plot_ratio_scatter(results,t_sel):
    d=get_arrays_for_time(results,t_sel);plt.figure(figsize=(7,4))
    for c in ["inert","food","organ"]:
        if c not in d: continue
        for m,r,f in zip(d[c]["mass"],d[c]["ratio"],d[c]["mode"]):
            plt.scatter(m,r,c=mode_color[f],marker=mode_marker[f],
                        edgecolors="black",alpha=0.8,label=f"{c}-{f}")
    plt.xscale("log");plt.yscale("log")
    plt.xlabel("Mass (kg)");plt.ylabel("E_need / (m c¬≤)")
    plt.title(f"Replicator Energy Fraction vs Mass @ t={t_sel:.0f}s")
    plt.grid(True,which="both",ls=":")
    h,l=plt.gca().get_legend_handles_labels();u=dict(zip(l,h))
    plt.legend(u.values(),u.keys(),fontsize=7);plt.tight_layout();plt.show()

# ---------- 3) dS vs mass ----------
def plot_dS_vs_mass(results,t_sel):
    d=get_arrays_for_time(results,t_sel)
    fig,ax=plt.subplots(figsize=(7,4))
    for c in ["inert","food","organ"]:
        if c not in d: continue
        scatter_mode(ax,d[c]["mass"],d[c]["dS_worst"],d[c]["mode"],c,
                     "Worst-case dS_eff","Worst-Case Entropy Gradient vs Mass")
    plt.tight_layout();plt.show()

# ---------- 4) JSON summary ----------
def summarize_results(results):
    out={"n_total":len(results),
         "classes":{},
         "times_s":sorted({float(r["t_s"]) for r in results})}
    for c in sorted({r["class"] for r in results}):
        s=[r for r in results if r["class"]==c];ce={"count":len(s),"failure_modes":{}}
        for fm in ["stable","power","biology"]:
            sub=[r for r in s if r["failure_mode"]==fm]
            if not sub: continue
            m=np.array([r["mass_kg"] for r in sub])
            rvs=np.array([r["ratio_vs_mc2"] for r in sub])
            ds=np.array([r["dS_worst"] for r in sub])
            ce["failure_modes"][fm]={"count":len(sub),
                "mass_kg_min":float(m.min()),"mass_kg_max":float(m.max()),
                "ratio_vs_mc2_median":float(np.median(rvs)),
                "dS_worst_mean":float(ds.mean())}
        out["classes"][c]=ce
    return out

try:
    print(json.dumps(summarize_results(results),indent=2))
except NameError:
    print("NOTE: Define `results` from Step 1 first to use this visualization.")
# Example calls after Step 1:
# plot_failure_mode_step(results,60.0)
# plot_ratio_scatter(results,60.0)
# plot_dS_vs_mass(results,60.0)
</pre>

<div class="nav-buttons">
  <button onclick="copyCode()">Copy Script</button>
  <button onclick="openRunner()">Open Python Runner (JupyterLite)</button>
</div>

<!-- ===== Bottom Navigation ===== -->
<div class="nav-buttons">
  <a href="../index.html"
     style="display:inline-block;background:#0e1624;color:#5ad0ff;border:1px solid #5ad0ff;
            padding:8px 14px;border-radius:6px;text-decoration:none;
            font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;
            font-size:0.9em;margin:6px;transition:background 0.3s;">
    ‚Üê Return to Index
  </a>
  <a href="https://x.com/that1sheldon" target="_blank"
     style="display:inline-block;background:#0e1624;color:#5ad0ff;border:1px solid #5ad0ff;
            padding:8px 14px;border-radius:6px;text-decoration:none;
            font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;
            font-size:0.9em;margin:6px;transition:background 0.3s;">
    ‚ú¶ Follow @that1sheldon on X
  </a>
  <a href="https://github.com/sheldonlindberg-afk/STUR-Physics-Lab" target="_blank"
     style="display:inline-block;background:#0e1624;color:#5ad0ff;border:1px solid #5ad0ff;
            padding:8px 14px;border-radius:6px;text-decoration:none;
            font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;
            font-size:0.9em;margin:6px;transition:background 0.3s;">
    ‚öõ GitHub Repository
  </a>
</div>
<!-- ===== End Navigation ===== -->

<p class="desc" style="text-align:center;">
Workflow:<br>
1Ô∏è‚É£ Run your <b>Step 1 STUR Replicator</b> cell to create <code>results</code>.<br>
2Ô∏è‚É£ Click <b>Copy Script</b> ‚Üí <b>Open Python Runner</b> ‚Üí paste ‚Üí run.<br>
3Ô∏è‚É£ Inspect plots and JSON summary outputs.
</p>

<footer>
 ¬© 2025 STUR Physics Lab ¬∑ Unified Resistance Framework ¬∑ Replicator Stress Envelope (Step 4)
</footer>

<script>
function copyCode(){
  const code=document.getElementById("codeBlock").innerText;
  navigator.clipboard.writeText(code);
  alert("‚úÖ STUR Replicator visualization code copied to clipboard");
}
function openRunner(){
  window.open("https://jupyter.org/try-jupyter/lab/","_blank");
}
</script>

</body>
</html>
